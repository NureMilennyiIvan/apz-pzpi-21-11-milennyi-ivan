1 ОПИС АРХІТЕКТУРИ СИСТЕМИ

Програмна система призначена для контролю роботи вовняної ферми. Вона реалізована на мові програмування Rust з використанням фреймворку ActixWeb для створення REST API, що забезпечує комунікацію між клієнтськими частинами та сервером. Система використовує HTTP протокол для передачі даних, причому кожен API метод має свою адресу та параметри. Дані, що надходять на сервер або відправляються з нього за допомогою HTTP, представлені у форматі JSON. REST API було обрано завдяки його простоті в реалізації та масштабованості. Така архітектура дозволяє легко інтегрувати різні клієнтські частини, включаючи веб-клієнт, мобільний додаток та пристрої IoT.
Фронтенд-частина системи, реалізована за допомогою фреймворку React і збирача Vite, взаємодіє з сервером через REST API, отримуючи та відправляючи дані у форматі JSON. Це забезпечує швидку та зручну розробку інтерфейсів користувача, які можуть динамічно оновлюватись відповідно до стану даних на сервері.
Мобільний додаток, розроблений для платформи Android, використовує аналогічну схему взаємодії з сервером через REST API. Це дозволяє користувачам отримувати актуальну інформацію та надсилати дані з будь-якого місця, забезпечуючи мобільність та доступність управління фермою.
Пристрої IoT, які використовуються для моніторингу температури та інших параметрів, також інтегруються з системою через REST API. Вони відправляють зібрані дані на сервер, де вони обробляються та зберігаються, що дозволяє забезпечити оперативний контроль за станом тварин та умовами їх утримання.
Для збереження інформації, що стосується працівників, овець, кормів, записів, сканерів та іншої інформації було обрано систему управління бази даних MySQL. MySQL Server на якому буде запущена база даних буде знаходитись на окремому сервері.

2 ПОБУДОВА ДІАГРАМИ РОЗГОРТАННЯ

На діаграмі розгортання (див. рисунок 2.1) зображена структура програмної системи для контролю роботи вовняної ферми, яка складається з наступних компонентів:
- **Backend Server**: Реалізований з використанням фреймворку Actix Web. Містить такі компоненти:
  - **Services**: Обробляє бізнес-логіку та взаємодіє з базою даних через пакет `sqlx`.
  - **Endpoints**: Відповідає за маршрутизацію HTTP-запитів, викликає методи сервісів, управляє помилками та надсилає відповіді клієнтам.
- **Database Server**: На окремому сервері розміщена база даних MySQL, яка зберігає інформацію про працівників, овець, корма, записи сканерів та інші дані. З'єднання з серверною частиною відбувається через протокол TCP/IP.
- **Web Server**: Веб-сервер, на якому розгорнуто фронтенд-частину програми, реалізовану за допомогою фреймворку React та збирача Vite. Містить такі компоненти:
  - **React Components**: Відповідають за відображення інтерфейсу користувача.
  - **Services**: Взаємодіють з серверною частиною через HTTP-запити.
- **Temperature Scanner (IoT)**: Пристрій IoT, що збирає дані про температуру та відправляє їх на сервер через HTTP. Складається з таких компонентів:
  - **Main Loop**: Основний цикл роботи пристрою, який збирає та передає дані.
- **Android Mobile**: Мобільний додаток для платформи Android, який забезпечує мобільний доступ до системи. Містить такі компоненти:
  - **Services**: Взаємодіють з серверною частиною через HTTP-запити для отримання та відправки даних.
Ця архітектура забезпечує зручну та ефективну взаємодію між усіма компонентами системи, дозволяючи забезпечити безперервний контроль та управління фермою. Використання HTTP-протоколу та REST API дозволяє легко масштабувати систему та інтегрувати нові клієнтські частини.

3 ОПИС АРХІТЕКТУРИ IOT ЧАСТИНИ

Для реалізації IoT частини була обрана мова програмування Rust. Ця мова була обрана через те, що вона, як і мова програмування C, напряму підтримує розробку програмного забезпечення для пристроїв без операційних систем та вбудованих девайсів. Так як популярні редактори для емуляції та будування схем Embedded пристроїв на момент розробки не підтримують можливість писати та запускати код на Rust, а при розробці не було доступу до пристрою температурного сканера і можливості тестувати на ньому код, то було прийнято рішення земулювати температурний сканер, використовуючи асинхронний runtime tokio та стандартну бібліотеку. IoT пристрій використовує HTTP протокол для передачі даних для зв’язку із серверною частиною.
Для того щоб сканер почав свою роботу він обов’язково повинен пройти автентифікацію на сервері.
Всі ендпоінти, які використовуються для автентифікації, обміну даними та управління компонентами системи, чітко визначені та описані у REST специфікації. Це дозволяє забезпечити надійну та ефективну комунікацію між IoT пристроями та сервером.
Реалізація емуляції IoT частини системи управління температурним сканером передбачає за допомогою мови Rust передбачає побудову архітектури, яка у разі необхідності зможе бути легко змінена та адаптована до вбудованих пристроїв і може бути переписана без використання стандартної бібліотеки.
Робота програми відбувається у методі main (див. Додаток А пункт А.1), на початку роботи якого відбувається отримання URL сервера зі змінної середовища виконується за допомогою, де у разі помилки викликається спеціально розроблена функція з модуля utils.rs (див. Додаток А пункт А.2) — panic(), яка припиняє роботу програми з відповідним повідомленням шляхом запуску нескінченого циклу. Це важливо для забезпечення надійності системи, оскільки без правильного URL серверу подальша робота є неможливою.
Перед початком роботи сканера відбувається аутентифікація на сервері. Для цього зчитуються та форматуються аргументи командного рядка за допомогою функції з модуля auth.rs (див. Додаток А пункт А.3) read_and_format_cli_arguments(). Введені користувачем дані (ідентифікатор сканера та пароль) перевіряються на коректність та формуються у структуру TemperatureScannerAuthJson.
Процес аутентифікації реалізовано у функції authenticate() з модуля auth.rs, яка надсилає HTTP POST-запит на сервер для перевірки автентичності сканера. У разі успішної аутентифікації програма продовжує роботу, в іншому випадку викликається функція panic().
Основний цикл програми реалізовано у вигляді нескінченного циклу, який зчитує температуру та надсилає її на сервер через фіксовані інтервали часу. Початкова температура встановлюється на рівні 370 (у сотих долях градуса), що дозволяє моделювати реальні умови роботи сканера.
Зчитування температури виконується функцією read_temperature() з модуля temperature.rs (див. Додаток А пункт А.4), яка генерує нове значення температури в межах заданих мінімальних і максимальних значень. Для цього використовується генератор випадкових чисел, що додає випадкове значення до попередньої температури, забезпечуючи природну варіацію даних.
Передача температури на сервер здійснюється функцією send_temperature() з модуля temperature.rs, яка формує та надсилає HTTP PATCH-запит до сервера. Відповідь сервера обробляється для визначення успішності операції. У разі успіху програма робить затримку на 5 секунд перед наступним циклом, в іншому випадку відображається повідомлення про помилку і користувачеві пропонується самостійно запустити цикл далі за допомогою функції continue_action() з модуля utils.rs.
Обробка помилок в системі реалізована за допомогою спеціального перерахування ScannerError з модуля scanner_error.rs (див. Додаток А пункт А.5), яке описує різні типи можливих помилок (помилки аргументів, оновлення температури, аутентифікації). Для кожного типу помилки реалізовано форматування повідомлень, що забезпечує зручне відображення інформації для користувача.
Функція panic() використовується для завершення програми у разі критичних помилок, таких як невірні змінні середовища або невдала аутентифікація. Вона відображає повідомлення про помилку і зупиняє програму, що дозволяє уникнути некоректної роботи системи.
Функція display() з модуля utils.rs використовується для виведення всіх повідомлень, які може надсилати пристрій.
Таким чином, реалізація IoT частини системи забезпечує ефективний збір, обробку та передачу даних про температуру, що є важливим для догляду за вівцями.

4 ПОБУДОВА ДІАГРАМИ ПРЕЦЕДЕНТІВ

Предметна область включає п’ять типів користувачів. Перший тип — це неавторизований користувач, який, використовуючи веб-клієнт або мобільний додаток, має можливість тільки авторизуватись. Другий тип – це вівчар, який, використовуючи веб-клієнт або мобільний додаток, має можливість взаємодіяти з серверною частиною системи, користуватися її функціями та переглядати необхідну інформацію про овець, а також відмічати годування та стрижки. Третій тип – це комірник, який, також за допомогою веб-клієнта або мобільного додатку, може взаємодіяти з серверною частиною та виконувати свої обов'язки. Він відповідає за контроль ресурсів ферми, таких як кількість кормів і їх витрати, а також відмічає нові поставки кормів. Четвертий тип користувача – це фермер або бізнес-адміністратор, який через веб-клієнт може маніпулювати певними даними та процесами за допомогою графічного інтерфейсу. Основні функції цього типу користувача включають додавання нових комірників, вівчарів, овець, порід, кормів та сканерів температури. Крім того, фермер визначає, за якими вівцями буде доглядати вівчар, та який температурний сканер буде використовуватися для вимірювання температури овець. П’ятий тип користувача – це адміністратор бази даних, який має змогу безпосередньо взаємодіяти з серверною частиною та базою даних системи. Він має доступ до всіх методів маніпулювання даними, забезпечуючи їх цілісність та актуальність, що є критично важливим для стабільної роботи системи. Крім того, в системі використовується температурний сканер, який здатний вимірювати температуру овець та зберігати ці дані завдяки інтеграції з серверною частиною системи. Інформація, зібрана сканером, допомагає забезпечити здоров'я тварин та своєчасно реагувати на будь-які відхилення від нормальних параметрів. Таким чином, предметна область охоплює різні аспекти функціонування вовняної ферми, забезпечуючи інтеграцію та ефективну взаємодію між усіма типами користувачів та компонентами системи. Це сприяє покращенню управління фермою, підвищенню продуктивності та створенню оптимальних умов для догляду за вівцями.
Першим типом користувача є неавторизований користувач. Йому доступна лише функція авторизації. Описані функціональні потреби повністю відповідають необхідним для неавторизованого користувача функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 4.1.
Вівчар є одним з двох основних типів користувачів для даної предметної області. Він повинен мати доступ до списку овець, які закріплені за ним, списку порід та кормів, що знаходяться на фермі. Вівчар також повинен мати змогу переглядати детальну інформацію про кожну з овець, які закріплені за ним, включаючи їхню температуру та дати останніх стрижок і годувань. Крім того, вівчар повинен мати доступ до історії записів про годування та стрижки овець. Важливо, щоб вівчар мав змогу додавати нові записи у випадку, якщо він підстриг або погодував вівцю. Описані функціональні потреби повністю відповідають необхідним для вівчаря функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 4.2.                
Комірник є ще одним типом користувачів системи, призначеним для управління ресурсами ферми. Комірник має доступ до функції перегляду списку кормів, що є основною функцією. Також комірник може створювати відмітки про поставку корму, що є важливою частиною підтримання актуальної інформації про наявність ресурсів на фермі. Крім того, комірник може переглядати список поставок корму. Це дозволяє йому відстежувати історію поставок та планувати майбутні потреби. Ще одна функція – це перегляд списку годувань кормом, що допомагає комірнику контролювати витрати кормів і забезпечувати, щоб усі тварини отримували необхідне харчування. Описані функціональні потреби повністю відповідають необхідним для комірника функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 4.3.
Фермер (бізнес-адміністратор) є ключовим користувачем системи, який має доступ до широкого спектру функцій через адмін-панель. Основною функцією фермера є доступ до адмін-панелі, що дозволяє йому виконувати різні операції, такі як перегляд, додавання, редагування та видалення даних. Через адмін-панель фермер може управляти всіма аспектами ферми. Він має можливість переглядати історію годувань, стрижок і поставок кормів, а також видаляти ці записи при необхідності. Фермер також може переглядати список усіх комірників, вівчарів та овець. Він має змогу додавати нових комірників та вівчарів, редагувати їх або видаляти. Щодо овець, фермер може переглядати інформацію про них, додавати нових овець, редагувати та видаляти їх. Крім того, він має доступ до інформації про всі породи овець на фермі, кормів та температурних сканерів. Це дозволяє фермеру додавати нові корми та породи, редагувати існуючі записи та видаляти їх. Додатково фермер може переглядати інформацію про всі температурні сканери, а також додавати, редагувати та видаляти їх. Важливою функцією є можливість призначати сканери для вимірювання температури конкретних овець, а також призначати вівчарів для догляду за конкретними овець. Описані функціональні потреби повністю відповідають необхідним для фермера (бізнес-адміністратора) функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 4.4.
Адміністратор бази даних є ще одним важливим типом користувачів системи, який повинен мати прямий доступ до серверного додатку, щоб мати повний доступу до усіх функцій та бази даних. Адміністратор бази даних має можливість здійснювати різні операції з даними. В першу чергу, він володіє повним доступом до бази даних, що дозволяє йому виконувати основні дії, такі як додавання, редагування, перегляд та видалення даних. Функція додавання дозволяє адміністратору вводити нові записи до бази даних, забезпечуючи актуальність та повноту інформації. Редагування дає змогу змінювати існуючі записи, вносячи необхідні корективи та оновлення. Перегляд забезпечує доступ до даних для аналізу та перевірки їхньої точності. Видалення дає змогу видаляти застарілі або некоректні записи, підтримуючи чистоту та релевантність бази даних. Описані функціональні потреби повністю відповідають необхідним для адміністратора функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 4.5.

5 ПОБУДОВА ДІАГРАМИ ДІЯЛЬНОСТІ

Діаграма діяльності (див. рисунок 5.1) відображає процес роботи температурного сканера з моменту його запуску до відправки даних на сервер і очікування перед наступним циклом. Нижче наведено детальний опис кожного кроку на діаграмі.
Launch scanner (Запуск сканера):
Початковий крок, коли сканер запускається.
Establish connection with server (Встановити з'єднання з сервером):
Сканер встановлює з'єднання з сервером для подальшої комунікації.
Succesful? (Успішно?):
Перевіряється, чи встановлено з'єднання з сервером успішно.
Якщо так, перехід до наступного кроку.
Якщо ні, повернення до кроку встановлення з'єднання.
Read credentials from user (Зчитування облікових даних користувача):
Сканер зчитує облікові дані від користувача для автентифікації.
Authenticate (Автентифікація):
Сканер автентифікується на сервері, використовуючи облікові дані користувача.
Succesful? (Успішно?):
Перевіряється, чи автентифікація пройшла успішно.
Якщо так, перехід до наступного кроку.
Якщо ні, перехід до кроку паніки.
Read temperature (Зчитування температури):
Сканер зчитує температуру від відповідного датчика.
Succesful? (Успішно?):
Перевіряється, чи зчитування температури пройшло успішно.
Якщо так, перехід до наступного кроку.
Якщо ні, повернення до кроку зчитування температури.
Send temperature (Відправка температури):
Сканер відправляє зчитані дані температури на сервер.
Succesful? (Успішно?):
Перевіряється, чи відправка даних пройшла успішно.
Якщо так, перехід до наступного кроку.
Якщо ні, повернення до кроку відправки температури.
Set a delay (Встановити затримку):
Після успішного відправлення даних сканер встановлює затримку перед наступним циклом.
Panic (Паніка):
Якщо будь-який з кроків (окрім встановлення з'єднання або відправки даних) не пройшов успішно, сканер переходить у стан паніки і процес завершується.
Ця діаграма діяльності ілюструє послідовність дій, які виконує температурний сканер для зчитування та відправки даних температури, включаючи перевірки успішності кожного етапу.

6 ПОБУДОВА ДІАГРАМИ ВЗАЄМОДІЇ

Діаграма взаємодії (див. рисунок 6.1) ілюструє процес взаємодії між користувачем, температурним сканером і сервером. Вона показує обмін повідомленнями між цими компонентами системи.
User (Користувач):
Prompt for credentials (Запит облікових даних):
Температурний сканер запитує облікові дані у користувача.
Provide credentials (Надання облікових даних):
Користувач надає свої облікові дані сканеру.
Temperature scanner (Температурний сканер):
Establish connection (Встановлення з'єднання):
Сканер встановлює з'єднання з сервером.
Connection response (Відповідь на з'єднання):
Сервер відповідає на запит встановлення з'єднання.
Authentication request (Запит на автентифікацію):
Сканер надсилає на сервер запит на автентифікацію з наданими обліковими даними.
Authentication response (Відповідь на автентифікацію):
Сервер відповідає на запит автентифікації, підтверджуючи або відхиляючи його.
Read temperature (Зчитування температури):
Сканер зчитує температуру з відповідного датчика.
Send temperature (Відправка температури):
Сканер відправляє зчитані дані температури на сервер.
Server response (Відповідь сервера):
Сервер відповідає на відправку даних, підтверджуючи їх отримання.
Set a delay (Встановлення затримки):
Сканер встановлює затримку перед наступним циклом зчитування температури.
Restart loop (Перезапуск циклу):
Після завершення затримки сканер перезапускає цикл зчитування температури та відправки даних на сервер.
Server (Сервер):
Connection response (Відповідь на з'єднання):
Сервер відповідає на запит встановлення з'єднання від сканера.
Authentication response (Відповідь на автентифікацію):
Сервер відповідає на запит автентифікації, підтверджуючи або відхиляючи його.
Server response (Відповідь сервера):
Сервер відповідає на відправку даних температури, підтверджуючи їх отримання.
Ця діаграма взаємодії ілюструє покроковий обмін повідомленнями між користувачем, температурним сканером та сервером для виконання завдання зчитування та відправки даних температури.

7 ПОБУДОВА ДІАГРАМИ КОМПОНЕНТІВ

Діаграма компонентів (див. рисунок 7.1) відображає загальну архітектуру системи контролю роботи вовняної ферми, з особливим акцентом на IoT-компонент. Інші компоненти будуть розглянуті детальніше у наступних розділах.
На діаграмі зображені наступні основні компоненти системи:
Backend Server (Сервер бекенду):
Основний компонент, що забезпечує обробку даних і реалізацію бізнес-логіки програми. Сервер бекенду взаємодіє з різними клієнтськими додатками і IoT-пристроями, забезпечуючи обмін даними.
Database Server (Сервер бази даних):
Цей сервер відповідає за зберігання всіх даних системи, включаючи інформацію про овець, вівчарів, корми та інші сутності. Взаємодія з базою даних здійснюється через сервер бекенду.
Web Server (Веб-сервер):
Цей сервер обслуговує веб-клієнти, забезпечуючи користувачам доступ до веб-інтерфейсу системи. Він передає запити до сервера бекенду для обробки та отримання необхідних даних.
Mobile App (Мобільний додаток):
Мобільний додаток дозволяє вівчарям і комірникам взаємодіяти з системою через свої мобільні пристрої. Він також взаємодіє з сервером бекенду для отримання та відправки даних.
IoT (Інтернет речей):
Цей компонент відповідає за інтеграцію з пристроями IoT, такими як температурні сканери. Основні частини IoT-компонента включають:
Main loop (Основний цикл): Відповідає за постійний збір даних з температурних сканерів і відправку їх на сервер бекенду.
Thermometer (Термометр): Пристрій, що здійснює вимірювання температури овець і передає ці дані через основний цикл на сервер бекенду.
Таким чином, архітектура системи забезпечує ефективну взаємодію між різними компонентами, дозволяючи здійснювати контроль і управління всіма аспектами роботи вовняної ферми.

ВИСНОВКИ

Під час виконання лабораторної роботи була розроблена IoT частина для програмної системи для контролю роботи вовняної ферми.

ДОДАТОК А
IoT частина

А.1 Файл main.rs

1  // Головна асинхронна функція
2  #[tokio::main]
3  async fn main() -> ! {
4      // Завантаження змінних середовища з файлу .env
5      dotenv().ok();
6
7      // Отримання URL сервера зі змінної середовища
8      let server_url: String = match env::var("SERVER_URL") {
9          Ok(url) => url,
10         Err(error) => panic(&error.to_string()) // Виклик паніки у разі помилки
11     };
12
13     // Читання та форматування аргументів командного рядка для аутентифікації
14     let auth = match read_and_format_cli_arguments() {
15         Ok(auth) => auth,
16         Err(error) => {
17             panic(&error.to_string()) // Виклик паніки у разі помилки
18         }
19     };
20
21     // Аутентифікація на сервері
22     if let Err(error) = authenticate(&auth, &server_url).await {
23         panic(&error.to_string()) // Виклик паніки у разі помилки
24     }
25
26     // Початкова температура
27     let mut temperature: u16 = 370;
28
29     // Основний цикл програми
30     loop {
31         // Читання температури
32         temperature = read_temperature(temperature);
33
34         // Надсилання температури на сервер
35         match send_temperature(auth.id, temperature, &server_url).await {
36             Ok(result) => {
37                 display(&format!("{}", result)); // Відображення результату
38                 sleepAsync(Duration::from_millis(5000)).await; // Затримка на 5 секунд
39             },
40             Err(error) => {
41                 display(&format!("Fix and try again. {}", error.to_string())); // Відображення помилки
42                 continue_action(); // Продовження дії після помилки
43             }
44         }
45     }
46 }

А.2 Модуль utils.rs

1  // Функція для відображення повідомлення
2  pub(crate) fn display(message: &str) -> () {
3      println!("{}", message);
4  }
5
6  // Функція для продовження дії після введення користувачем
7  pub(crate) fn continue_action() -> () {
8      display("Press ENTER to try again.");  // Відображення повідомлення
9      let mut input = String::new();
10     if let Err(error) = io::stdin().read_line(&mut input) {  // Зчитування введення користувача
11         panic(&error.to_string())  // Виклик функції panic у разі помилки
12     }
13 }
14
15 // Функція для паніки з повідомленням
16 pub(crate) fn panic(message: &str) -> ! {
17     display(&message.to_string());  // Відображення повідомлення про паніку
18     loop {
19         sleep(Duration::from_millis(100000))  // Затримка для імітації нескінченного циклу
20     }
21 }

А.3 Модуль auth.rs

1  // Структура для збереження аутентифікаційних даних
2  pub(crate) struct TemperatureScannerAuthJson {
3      pub id: u64,
4      pub password: String,
5  }
6
7  // Функція для зчитування та форматування аргументів командного рядка
8  pub(crate) fn read_and_format_cli_arguments() -> Result<TemperatureScannerAuthJson, ScannerError> {
9      let mut id_input = String::new();
10     let mut password_input = String::new();
11
12     // Запит введення ідентифікатора сканера
13     print!("Provide scanner ID: ");
14     if let Err(error) = io::stdout().flush() {
15         return Err(ScannerError::ArgumentsError(error.to_string()));
16     }
17     if let Err(error) = io::stdin().read_line(&mut id_input) {
18         return Err(ScannerError::ArgumentsError(error.to_string()));
19     }
20     // Парсинг введеного ідентифікатора
21     let id: u64 = match id_input.trim().parse() {
22         Ok(id) => id,
23         Err(error) => return Err(ScannerError::ArgumentsError(error.to_string()))
24     };
25
26     // Запит введення пароля сканера
27     print!("Provide scanner password: ");
28     if let Err(error) = io::stdout().flush() {
29         return Err(ScannerError::ArgumentsError(error.to_string()));
30     }
31     if let Err(error) = io::stdin().read_line(&mut password_input) {
32         return Err(ScannerError::ArgumentsError(error.to_string()));
33     }
34     let password = password_input.trim().to_string();
35
36     // Повернення структури з аутентифікаційними даними
37     Ok(TemperatureScannerAuthJson { id, password })
38 }
39
40 // Функція для аутентифікації на сервері
41 pub(crate) async fn authenticate(auth: &TemperatureScannerAuthJson, server_url: &str) -> Result<(), ScannerError> {
42     let client = Client::new();
43     let url = format!("{}authenticate/{}", server_url, auth.id);
44     let body = object!{
45         password: *auth.password,
46     }.dump();
47
48     // Надсилання POST-запиту на сервер
49     let response = match client.post(&url).header("Content-Type", "application/json").body(body).send().await {
50         Ok(res) => res,
51         Err(error) => return Err(ScannerError::AuthenticationError(error.to_string()))
52     };
53
54     // Обробка відповіді від сервера
55     match response.json::<bool>().await {
56         Ok(result) => if result {
57             Ok(())
58         } else {
59             Err(ScannerError::AuthenticationError("This device failed authentication".to_string()))
60         },
61         Err(error) => Err(ScannerError::AuthenticationError(error.to_string()))
62     }
63 }

А.4 Модуль temperature.rs

1  // Функція для зчитування температури
2  pub(crate) fn read_temperature(previous_temp: u16) -> u16 {
3      let mut rng = rand::thread_rng();
4      let min_temp = 360;  // Мінімальна температура
5      let max_temp = 400;  // Максимальна температура
6      let step = 1;        // Крок зміни температури
7
8      // Обчислення нової температури
9      let new_temp = if previous_temp < min_temp {
10         min_temp
11     } else if previous_temp > max_temp {
12         max_temp
13     } else {
14         let delta = rng.gen_range(-step..=step);  // Випадкове значення зміни температури
15         let temp = previous_temp as i16 + delta;
16         temp.max(min_temp as i16).min(max_temp as i16) as u16
17     };
18     display(&format!("Temperature is {}", new_temp));  // Відображення нової температури
19     new_temp
20 }
21
22 // Асинхронна функція для відправки температури на сервер
23 pub(crate) async fn send_temperature(id: u64, temp: u16, server_url: &str) -> Result<String, ScannerError>  {
24     let client = Client::new();
25     let url = format!("{}update-temperature/{}", server_url, id);  // Формування URL для запиту
26
27     let body = object!{
28             temperature: temp,
29     }.dump();  // Формування тіла запиту
30
31     // Відправка запиту на сервер
32     let response = match client.patch(&url).header("Content-Type", "application/json").body(body).send().await{
33         Ok(res) => res,
34         Err(error) => return Err(ScannerError::UpdatingError(error.to_string()))
35     };
36
37     // Обробка відповіді сервера
38     match response.json().await{
39         Ok(text) => Ok(text),
40         Err(error) => return Err(ScannerError::UpdatingError(error.to_string()))
41     }
42 }

А.5 Модуль scanner_error.rs

1  // Перерахування можливих помилок сканера
2  #[derive(Debug)]
3  pub(crate) enum ScannerError {
4      ArgumentsError(String),          // Помилка аргументів
5      UpdatingError(String),           // Помилка оновлення температури
6      AuthenticationError(String)      // Помилка аутентифікації
7  }
8  
9  // Реалізація Display для ScannerError
10 impl Display for ScannerError {
11     fn fmt(&self, formatter: &mut Formatter<'_>) -> std::fmt::Result {
12         match &self {
13             // Форматування помилки аргументів
14             ScannerError::ArgumentsError(error) => write!(formatter, "Arguments error: {}.\nPlease restart device and try again", error),
15             // Форматування помилки оновлення температури
16             ScannerError::UpdatingError(error) => write!(formatter, "Updating temperature error: {}", error),
17             // Форматування помилки аутентифікації
18             ScannerError::AuthenticationError(error) => write!(formatter, "Authentication error: {}. \nPlease restart device and try again", error)
19         }
20     }
21 }
22
23 // Реалізація Error для ScannerError
24 impl Error for ScannerError { }
