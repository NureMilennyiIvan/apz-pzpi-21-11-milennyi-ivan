1 ОПИС АРХІТЕКТУРИ СИСТЕМИ

Програмна система призначена для контролю роботи вовняної ферми. Вона реалізована на мові програмування Rust з використанням фреймворку ActixWeb для створення REST API, що забезпечує комунікацію між клієнтськими частинами та сервером. Система використовує HTTP протокол для передачі даних, причому кожен API метод має свою адресу та параметри. Дані, що надходять на сервер або відправляються з нього за допомогою HTTP, представлені у форматі JSON. REST API було обрано завдяки його простоті в реалізації та масштабованості. Така архітектура дозволяє легко інтегрувати різні клієнтські частини, включаючи веб-клієнт, мобільний додаток та пристрої IoT.
Фронтенд-частина системи, реалізована за допомогою фреймворку React і збирача Vite, взаємодіє з сервером через REST API, отримуючи та відправляючи дані у форматі JSON. Це забезпечує швидку та зручну розробку інтерфейсів користувача, які можуть динамічно оновлюватись відповідно до стану даних на сервері.
Мобільний додаток, розроблений для платформи Android, використовує аналогічну схему взаємодії з сервером через REST API. Це дозволяє користувачам отримувати актуальну інформацію та надсилати дані з будь-якого місця, забезпечуючи мобільність та доступність управління фермою.
Пристрої IoT, які використовуються для моніторингу температури та інших параметрів, також інтегруються з системою через REST API. Вони відправляють зібрані дані на сервер, де вони обробляються та зберігаються, що дозволяє забезпечити оперативний контроль за станом тварин та умовами їх утримання.
Для збереження інформації, що стосується працівників, овець, кормів, записів, сканерів та іншої інформації було обрано систему управління бази даних MySQL. MySQL Server на якому буде запущена база даних буде знаходитись на окремому сервері.

2 ПОБУДОВА ДІАГРАМИ РОЗГОРТАННЯ

На діаграмі розгортання (див. рисунок 2.1) зображена структура програмної системи для контролю роботи вовняної ферми, яка складається з наступних компонентів:
- **Backend Server**: Реалізований з використанням фреймворку Actix Web. Містить такі компоненти:
  - **Services**: Обробляє бізнес-логіку та взаємодіє з базою даних через пакет `sqlx`.
  - **Endpoints**: Відповідає за маршрутизацію HTTP-запитів, викликає методи сервісів, управляє помилками та надсилає відповіді клієнтам.
- **Database Server**: На окремому сервері розміщена база даних MySQL, яка зберігає інформацію про працівників, овець, корма, записи сканерів та інші дані. З'єднання з серверною частиною відбувається через протокол TCP/IP.
- **Web Server**: Веб-сервер, на якому розгорнуто фронтенд-частину програми, реалізовану за допомогою фреймворку React та збирача Vite. Містить такі компоненти:
  - **React Components**: Відповідають за відображення інтерфейсу користувача.
  - **Services**: Взаємодіють з серверною частиною через HTTP-запити.
- **Temperature Scanner (IoT)**: Пристрій IoT, що збирає дані про температуру та відправляє їх на сервер через HTTP. Складається з таких компонентів:
  - **Main Loop**: Основний цикл роботи пристрою, який збирає та передає дані.
- **Android Mobile**: Мобільний додаток для платформи Android, який забезпечує мобільний доступ до системи. Містить такі компоненти:
  - **Services**: Взаємодіють з серверною частиною через HTTP-запити для отримання та відправки даних.
Ця архітектура забезпечує зручну та ефективну взаємодію між усіма компонентами системи, дозволяючи забезпечити безперервний контроль та управління фермою. Використання HTTP-протоколу та REST API дозволяє легко масштабувати систему та інтегрувати нові клієнтські частини.

3 ОПИС АРХІТЕКТУРИ ВЕБ ЧАСТИНИ

Клієнтська частина має архітектуру, яка використовує React TS як основний фронтенд фреймворк, що забезпечує всі необхідні інструменти та можливості для створення клієнтських додатків. Для взаємодії з сервером будуть застосовуватись HTTP-методи, які направлятимуться на адресу REST API та міститимуть маршрут до відповідного методу.
React заснований на концепції компонентів, що дає змогу створювати веб-інтерфейс із невеликих, повторно використовуваних елементів. Це значно спрощує розробку та підтримку великих проектів. Крім того, React використовує віртуальний DOM для ефективного оновлення відображення при зміні даних, що робить додаток більш продуктивним і швидкодійним. Використання віртуального DOM є ключовою особливістю React, оскільки це робить його ідеальним вибором для створення SPA, де весь контент завантажується одноразово під час запуску додатка, а подальша навігація здійснюється без повторного завантаження сторінок. React має найбільшу та найрозвиненішу екосистему серед усіх наявних фронтенд фреймворків на сьогодні. Поєднання всіх цих факторів робить React дуже ефективним рішенням для створення клієнтських веб-додатків.
Веб-клієнт використовує структуровану систему HTTP-запитів та методів для забезпечення взаємодії з серверними ресурсами. Ці запити створюються та проходять валідацію, щоб гарантувати безпечний та ефективний доступ до серверних методів. Компонентна архітектура веб-клієнта включає складні залежності між окремими компонентами, що дозволяє досягти високого рівня інтеграції та узгодженості в роботі додатка.
Реалізація веб-клієнта починається з файлу main.tsx. В ньому створюється об'єкт resources, який містить переклади для англійської та української мов. Потім ініціалізується i18next з використанням initReactI18next для інтеграції з React. Налаштовуються ресурси для перекладів, встановлюється мова за замовчуванням (українська) та резервна мова (також українська), а також вимикається escaping для безпеки. Після цього викликається ReactDOM.createRoot для рендерингу кореневого компонента Router у DOM елемент з ідентифікатором root.
Компонент Router (див. Додаток А пункт А.1) відповідає за маршрутизацію застосунку та управління станом авторизації користувача. Використовується стан для зберігання авторизованого користувача, а також функція для виходу з акаунту, яка оновлює стан і зберігає неавторизованого користувача в Local Storage. При завантаженні компонента виконується useEffect для завантаження користувача з Local Storage. Для багатомовності використовується i18n, а функція changeLanguage дозволяє змінювати мову інтерфейсу. Маршрутизація здійснюється за допомогою BrowserRouter, Routes та Route, забезпечуючи навігацію між різними сторінками застосунку. Додаються різні маршрути для сторінок, таких як головна сторінка, сторінки з інформацією про овець, корми, пастухів, комірників та інші.
Компонент App.tsx відповідає за рендеринг головної сторінки залежно від ролі користувача. Використовується React.FC для визначення типу компонента, а також властивості user та setUser. Виклик useEffectUser забезпечує навігацію на відповідні сторінки залежно від ролі користувача. Компонент рендерить різні підкомпоненти залежно від ролі користувача: AuthorizationForm для неавторизованих користувачів, ShepherdMainPage для пастухів, StorekeeperMainPage для комірників та AdminMainPage для фермерів.  Сторінка  AuthorizationForm надає можливість зареєструватись, а сторінки  ShepherdMainPage,  StorekeeperMainPage та  AdminMainPage надають доступ своїм типам користувачам до функціоналу описаного в попередньому розділі.
Для розуміння логіки та архітектури системи розглянемо структуру сервісу «SheepService» (див. Додаток А пункт А.2), оскільки він має найбільше функціоналу, та імплементацію методів інтерфейсів «IService» та «ISheepService». Структура «SheepService» містить статичні URL-адреси для запитів до API, які забезпечують зв’язок з бекендом. Ця структура була створена для інкапсуляції бізнес-логіки у методах, до яких можливо звернутись через цю структуру. Цей патерн проектування називається Service Layer. Цей патерн допомагає створювати добре структуровані, підтримувані та масштабовані додатки з чітким розділенням бізнес-логіки від інших частин системи.
Перший інтерфейс, який реалізує «SheepService», це «IService». Цей інтерфейс є базовим для всіх сервісів, тому його реалізують всі сервіси. Для його реалізації потрібно визначити методи: create, delete, update, getAll, getById. Метод create відповідає за створення нової вівці за допомогою POST-запиту до API; метод delete видаляє вівцю за її ідентифікатором за допомогою DELETE-запиту; метод update оновлює інформацію про вівцю за допомогою PUT-запиту; метод getAll отримує всіх овець за допомогою GET-запиту; метод getById отримує вівцю за її ідентифікатором за допомогою GET-запиту.
Також для реалізації інтерфейсу «IService» потрібно визначити асоційовані типи, а саме Model та ViewModel. В цій реалізації ці типи визначено як: Model — Sheep, ViewModel — SheepVM. Sheep це клас, який представляє сутність вівці з такими полями, як ідентифікатор, дата народження, ідентифікатор породи, вага, стать, ідентифікатор температурного сканера та пастуха. SheepVM це клас для відображення інформації про вівцю, який містить ідентифікатор, породу, стать, дату народження, дати останнього годування та стрижки.
Другий інтерфейс, який реалізує «SheepService», це «ISheepService», який є розширенням для інтерфейсу «IService». Тобто реалізація «ISheepService» неможлива без «IService». Це дає змогу використовувати асоційовані типи з «IService» у «ISheepService». Цей інтерфейс спеціалізується на управлінні даними, пов'язаними з вівцями, і додає додаткові методи, специфічні для цього сервісу. Для його реалізації потрібно визначити методи: getAllVMsByShepherdId, getDetailsById, changeShepherd, changeTemperatureScanner. Метод getAllVMsByShepherdId отримує всі моделі представлення овець за ідентифікатором пастуха за допомогою GET-запиту; метод getDetailsById отримує детальну інформацію про вівцю за її ідентифікатором за допомогою GET-запиту; метод changeShepherd змінює пастуха для вівці за допомогою PATCH-запиту; метод changeTemperatureScanner змінює сканер температури для вівці за допомогою PATCH-запиту.
Також для реалізації інтерфейсу «ISheepService» потрібно визначити асоційований тип DetailsViewModel. В цій реалізації цей тип визначено як SheepDetailsVM. SheepDetailsVM це клас, який містить детальну інформацію про вівцю, включаючи такі поля, як ідентифікатор, порода, інформація про породу, стать, вік, дати останнього годування та стрижки, вага, температура, ідентифікатор та назва корму, необхідна та доступна кількість корму, а також індикатори необхідності годування та стрижки.
Для відправлення запитів було прийнято рішення використовувати пакет axios оскільки він є зручнішою версією fetch.  
Розгляд інших 8 сервісів не є необхідним оскільки вони реалізовані за тією ж архітектурою. Кожен сервіс імплементує інтерфейс «IService» та має свій інтерфейс для специфічних методів. 
Також розглянемо модуль «helpers.ts» (див. Додаток А пункт А.3), який містить різноманітні допоміжні функції, що використовуються у фронтенд застосунку.
Функція timestampToDate призначена для конвертації мітки часу в дату у форматі "гг:хх дд.мм.рррр". Ця функція отримує мітку часу у секундах, створює новий об'єкт Date, витягує години, хвилини, день, місяць та рік з цього об'єкту, а потім форматує їх у вказаний формат.
Функція saveAuthUserToLocalStorage використовується для збереження авторизованого користувача в Local Storage. Вона приймає ключ і об'єкт користувача, серіалізує цей об'єкт у JSON і зберігає його в Local Storage під заданим ключем. У разі виникнення помилки, вона виводить повідомлення про помилку у консоль.
Функція getAuthUserFromLocalStorage призначена для отримання авторизованого користувача з Local Storage. Вона приймає ключ, зчитує збережений JSON, десеріалізує його та повертає об'єкт AuthUser. Якщо збережене значення не знайдено або виникає помилка, повертається об'єкт з неавторизованим користувачем.
Функція hashPassword використовується для хешування пароля. Вона приймає пароль, перетворює його у масив байтів, обчислює його SHA-256 хеш і повертає його у вигляді шестнадцяткового рядка.
Хук useEffectUser виконується при завантаженні компонента та перевіряє, чи авторизований користувач збережений у Local Storage. Якщо користувач не авторизований, він перенаправляє користувача на головну сторінку.
Функція handleElementChange обробляє зміну елементів форми. Вона приймає подію зміни елементу та функцію для оновлення стану, витягує значення з події та оновлює стан.
Функція timeInDays обчислює час у днях з мітки часу. Вона приймає мітку часу, обчислює різницю між поточним часом і переданою міткою, перетворює цю різницю у дні та повертає кількість днів.

4 ПОБУДОВА ДІАГРАМИ ПРЕЦЕДЕНТІВ

Предметна область включає п’ять типів користувачів. Перший тип — це неавторизований користувач, який, використовуючи веб-клієнт або мобільний додаток, має можливість тільки авторизуватись. Другий тип – це вівчар, який, використовуючи веб-клієнт або мобільний додаток, має можливість взаємодіяти з серверною частиною системи, користуватися її функціями та переглядати необхідну інформацію про овець, а також відмічати годування та стрижки. Третій тип – це комірник, який, також за допомогою веб-клієнта або мобільного додатку, може взаємодіяти з серверною частиною та виконувати свої обов'язки. Він відповідає за контроль ресурсів ферми, таких як кількість кормів і їх витрати, а також відмічає нові поставки кормів. Четвертий тип користувача – це фермер або бізнес-адміністратор, який через веб-клієнт може маніпулювати певними даними та процесами за допомогою графічного інтерфейсу. Основні функції цього типу користувача включають додавання нових комірників, вівчарів, овець, порід, кормів та сканерів температури. Крім того, фермер визначає, за якими вівцями буде доглядати вівчар, та який температурний сканер буде використовуватися для вимірювання температури овець. П’ятий тип користувача – це адміністратор бази даних, який має змогу безпосередньо взаємодіяти з серверною частиною та базою даних системи. Він має доступ до всіх методів маніпулювання даними, забезпечуючи їх цілісність та актуальність, що є критично важливим для стабільної роботи системи. Крім того, в системі використовується температурний сканер, який здатний вимірювати температуру овець та зберігати ці дані завдяки інтеграції з серверною частиною системи. Інформація, зібрана сканером, допомагає забезпечити здоров'я тварин та своєчасно реагувати на будь-які відхилення від нормальних параметрів. Таким чином, предметна область охоплює різні аспекти функціонування вовняної ферми, забезпечуючи інтеграцію та ефективну взаємодію між усіма типами користувачів та компонентами системи. Це сприяє покращенню управління фермою, підвищенню продуктивності та створенню оптимальних умов для догляду за вівцями.
Першим типом користувача є неавторизований користувач. Йому доступна лише функція авторизації. Описані функціональні потреби повністю відповідають необхідним для неавторизованого користувача функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 4.1.
Вівчар є одним з двох основних типів користувачів для даної предметної області. Він повинен мати доступ до списку овець, які закріплені за ним, списку порід та кормів, що знаходяться на фермі. Вівчар також повинен мати змогу переглядати детальну інформацію про кожну з овець, які закріплені за ним, включаючи їхню температуру та дати останніх стрижок і годувань. Крім того, вівчар повинен мати доступ до історії записів про годування та стрижки овець. Важливо, щоб вівчар мав змогу додавати нові записи у випадку, якщо він підстриг або погодував вівцю. Описані функціональні потреби повністю відповідають необхідним для вівчаря функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 4.2.                
Комірник є ще одним типом користувачів системи, призначеним для управління ресурсами ферми. Комірник має доступ до функції перегляду списку кормів, що є основною функцією. Також комірник може створювати відмітки про поставку корму, що є важливою частиною підтримання актуальної інформації про наявність ресурсів на фермі. Крім того, комірник може переглядати список поставок корму. Це дозволяє йому відстежувати історію поставок та планувати майбутні потреби. Ще одна функція – це перегляд списку годувань кормом, що допомагає комірнику контролювати витрати кормів і забезпечувати, щоб усі тварини отримували необхідне харчування. Описані функціональні потреби повністю відповідають необхідним для комірника функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 4.3.
Фермер (бізнес-адміністратор) є ключовим користувачем системи, який має доступ до широкого спектру функцій через адмін-панель. Основною функцією фермера є доступ до адмін-панелі, що дозволяє йому виконувати різні операції, такі як перегляд, додавання, редагування та видалення даних. Через адмін-панель фермер може управляти всіма аспектами ферми. Він має можливість переглядати історію годувань, стрижок і поставок кормів, а також видаляти ці записи при необхідності. Фермер також може переглядати список усіх комірників, вівчарів та овець. Він має змогу додавати нових комірників та вівчарів, редагувати їх або видаляти. Щодо овець, фермер може переглядати інформацію про них, додавати нових овець, редагувати та видаляти їх. Крім того, він має доступ до інформації про всі породи овець на фермі, кормів та температурних сканерів. Це дозволяє фермеру додавати нові корми та породи, редагувати існуючі записи та видаляти їх. Додатково фермер може переглядати інформацію про всі температурні сканери, а також додавати, редагувати та видаляти їх. Важливою функцією є можливість призначати сканери для вимірювання температури конкретних овець, а також призначати вівчарів для догляду за конкретними овець. Описані функціональні потреби повністю відповідають необхідним для фермера (бізнес-адміністратора) функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 4.4.
Адміністратор бази даних є ще одним важливим типом користувачів системи, який повинен мати прямий доступ до серверного додатку, щоб мати повний доступу до усіх функцій та бази даних. Адміністратор бази даних має можливість здійснювати різні операції з даними. В першу чергу, він володіє повним доступом до бази даних, що дозволяє йому виконувати основні дії, такі як додавання, редагування, перегляд та видалення даних. Функція додавання дозволяє адміністратору вводити нові записи до бази даних, забезпечуючи актуальність та повноту інформації. Редагування дає змогу змінювати існуючі записи, вносячи необхідні корективи та оновлення. Перегляд забезпечує доступ до даних для аналізу та перевірки їхньої точності. Видалення дає змогу видаляти застарілі або некоректні записи, підтримуючи чистоту та релевантність бази даних. Описані функціональні потреби повністю відповідають необхідним для адміністратора функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 4.5.

5 ПОБУДОВА ДІАГРАМИ СТАНІВ

Веб-клієнт надає весь необхідний функціонал, що потрібний для користування програмною системою для контролю роботи вовняної ферми. Для його опису було прийнято рішення побудувати диаграми станів для вівчаря, комірника та фермера.
При запуску додатку користувачу необхідно авторизуватись для отримання доступу до основного функціоналу. Під час авторизації користувач зможе обрати під якою роллю йому користуватись системою.
Якщо користувач авторизувався як вівчар, він відразу потрапляє на головну сторінку вівчаря. Після авторизації йому постійно доступні функції виходу з акаунту. На головній сторінці розташоване меню з трьома кнопками, які змінюють контент на головній сторінці за вибором вівчаря. Перша кнопка за замовчуванням активна і відображає під панеллю список овець, за якими він доглядає, а також основну інформацію про них. Друга кнопка показує список порід овець, які є на фермі, та інформацію про кожну породу. Третя кнопка демонструє список кормів, доступних на фермі, та інформацію про них. При натисканні на вівцю зі списку, вівчар перейде на сторінку з деталями про вівцю. На сторінці з деталями розташоване меню з трьома кнопками, які змінюють контент на сторінці з деталями за вибором вівчаря. Перша кнопка за замовчуванням активна і відображає під панеллю детальну інформацію про вівцю включаючи її номер, температуру, дати останніх годування та стрижки, породу та інформацію про неї, вік у днях та інше. Також поруч з датами про годування та стрижки вівчар зможе зробити відмітки про проведені стрижку або годування. Друга кнопка показує список з відмітками про годування цієї вівці та інформацію про них. Третя кнопка показує список з відмітками про стрижку цієї вівці та інформацію про них.
Діаграма станів, яка показує взаємодію вівчаря з веб-клієнтом наведена на рисунку 2.4.
Якщо користувач авторизувався як комірник, він відразу потрапляє на головну сторінку комірника. Після авторизації йому постійно доступні функції виходу з акаунту. На головній сторінці розташований список кормів, які є на фермі та інформація про них. На кожній картці корму розташована кнопка, яка відкриває форму для додавання нової поставки корму. При натисканні на корм зі списку, комірник перейде на сторінку корму. На сторінці корму розташоване меню з двома кнопками, які змінюють контент на сторінці корму за вибором вівчаря. Перша кнопка за замовчуванням активна і відображає під панеллю список поставок обраного корму, а також основну інформацію про них. Друга кнопка показує список годувань обраним кормом та інформацію них.
Діаграма станів, яка показує взаємодію комірника з веб-клієнтом наведена на рисунку 2.5.
Якщо користувач авторизувався як фермер, він відразу потрапляє на головну сторінку фермера. Після авторизації йому постійно доступні функції виходу з акаунту. На головній сторінці розташоване меню з дев’ятьма кнопками, яке дозволяє перемикати контент на головній сторінці за вибором фермера. Перша кнопка відображає таблицю з переліком вівчарів, які працюють на фермі. Під таблицею розташовані кнопки для додавання, зміни та видалення записів. Кнопка "Додати" доступна завжди, а кнопки "Змінити" та "Видалити" стають доступними тільки після вибору конкретного запису.
Друга кнопка відображає таблицю з переліком комірників. Під цією таблицею також є кнопки для додавання, зміни та видалення записів, де кнопка "Додати" доступна завжди, а "Змінити" та "Видалити" - лише при виборі запису.
Третя кнопка перемикає вміст на таблицю з переліком овець. Як і в попередніх випадках, під таблицею розташовані кнопки для додавання, зміни та видалення записів. Кнопка "Додати" доступна завжди, а кнопки "Змінити" та "Видалити" - тільки при виборі конкретного запису, а також дві додаткові кнопки для перепризначення вівчаря та перепризначення сканера температури. Кнопка "Перепризначити вівчаря" перенаправляє на сторінку перепризначення вівчаря для вибраної вівці. На цій сторінці знаходиться форма із номером вівці та випадаючим списком вівчарів. Після вибору потрібного вівчаря можна натиснути кнопку "Перепризначити", яка виконає зміну та поверне на головну сторінку фермера. Кнопка "Перепризначити сканер температури" перенаправляє на сторінку перепризначення сканера температури для вибраної вівці. На цій сторінці знаходиться форма із номером вівці та випадаючим списком вільних сканерів температури. Після вибору потрібного сканера можна натиснути кнопку "Перепризначити", яка виконає зміну та поверне на головну сторінку фермера.
Четверта кнопка відображає таблицю з переліком сканерів температури. Під таблицею також знаходяться кнопки для додавання, зміни та видалення записів. Кнопка "Додати" завжди доступна, а кнопки "Змінити" та "Видалити" стають доступними тільки після вибору запису.
П'ята кнопка показує таблицю з переліком порід овець. Під таблицею розташовані кнопки для додавання, зміни та видалення записів. Кнопка "Додати" завжди доступна, а кнопки "Змінити" та "Видалити" стають доступними лише після вибору конкретного запису.
Шоста кнопка перемикає вміст на таблицю з переліком кормів. Під таблицею знаходяться кнопки для додавання, зміни та видалення записів. Кнопка "Додати" завжди доступна, а кнопки "Змінити" та "Видалити" стають доступними лише при виборі запису.
Сьома кнопка відображає таблицю з переліком записів про годування. Під цією таблицею знаходиться лише кнопка для видалення записів, яка стає доступною тільки після вибору конкретного запису.
Восьма кнопка показує таблицю з переліком записів про стрижку. Під таблицею розташована тільки кнопка для видалення записів, яка стає доступною після вибору конкретного запису.
Дев'ята кнопка відображає таблицю з переліком поставок корму. Під цією таблицею знаходиться лише кнопка для видалення записів, яка стає доступною після вибору конкретного запису.
Натискання кнопок "Додати" та "Змінити" перенаправляє на сторінку з формою для створення або редагування запису. У формі для додавання поля будуть порожніми, і після їх заповнення фермер може натиснути кнопку "Додати", щоб створити новий запис. Після цього він буде повернений на головну сторінку фермера. У формі для редагування поля будуть заповнені обраним із таблиці записом. Після внесення змін фермер може натиснути кнопку "Змінити", і після збереження змін він буде повернений на головну сторінку фермера. Після натискання кнопки "Видалити" запис буде видалений з таблиці та бази даних.
Діаграма станів, яка показує взаємодію фермера з веб-клієнтом наведена на рисунку 2.6.

6 ПОБУДОВА ДІАГРАМИ КОМПОНЕНТІВ

Діаграма компонентів (див. рисунок 6.1) відображає загальну архітектуру системи контролю роботи вовняної ферми, з особливим акцентом на Web Server (Веб-сервер). Інші компоненти будуть розглянуті детальніше у наступних розділах.
На діаграмі зображені наступні основні компоненти системи:
Backend Server (Сервер бекенду):
Основний компонент, що забезпечує обробку даних і реалізацію бізнес-логіки програми. Сервер бекенду взаємодіє з різними клієнтськими додатками і IoT-пристроями, забезпечуючи обмін даними.
Database Server (Сервер бази даних):
Цей сервер відповідає за зберігання всіх даних системи, включаючи інформацію про овець, вівчарів, корми та інші сутності. Взаємодія з базою даних здійснюється через сервер бекенду.
Web Server (Веб-сервер):
Цей сервер обслуговує веб-клієнти, забезпечуючи користувачам доступ до веб-інтерфейсу системи. Веб-сервер складається з двох основних частин:
Components (Компоненти): Відповідають за відображення інтерфейсу користувача та взаємодію з користувачем.
Services (Сервіси): Забезпечують логіку програми і взаємодію з сервером бекенду для отримання та відправки даних.
Mobile App (Мобільний додаток):
Клієнтський додаток для мобільних пристроїв, що дозволяє вівчарям і комірникам взаємодіяти з системою. Мобільний додаток забезпечує зручний інтерфейс для користувачів, дозволяючи їм виконувати необхідні операції на фермі.
IoT (Інтернет речей):
Пристрої, такі як температурні сканери, що вимірюють і передають дані про температуру овець до серверу бекенду. Ці дані використовуються для моніторингу здоров'я овець і своєчасного реагування на відхилення від нормальних параметрів.
Взаємодія між компонентами:
Backend Server комунікує з Database Server через TCP/IP для доступу і збереження даних.
Mobile App, Web Server і IoT пристрої взаємодіють з Backend Server через HTTP, надсилаючи запити до відповідних кінцевих точок.
Endpoints на Backend Server обробляють запити, викликають відповідні сервіси для обробки бізнес-логіки і взаємодії з базою даних, і повертають результати назад до клієнтів.
Ця архітектура забезпечує модульність і масштабованість системи, що дозволяє легко додавати нові функціональні можливості і підтримувати існуючі компоненти.

ВИСНОВКИ

Під час виконання лабораторної роботи була розроблена фронтенд частина для програмної системи для контролю роботи вовняної ферми.

ДОДАТОК А
Веб-частина

А.1 Компонент Router.tsx

1  export const Router = () => {
2    // Стан для зберігання авторизованого користувача
3    const [user, setUser] = useState<AuthUser>(new AuthUser(null, UserRole.Unauthorized));
4
5    // Функція для виходу з системи
6    const logout = () => {
7      const unauthorized_user = new AuthUser(null, UserRole.Unauthorized);
8      saveAuthUserToLocalStorage("user", unauthorized_user);
9      setUser(unauthorized_user);
10   }
11
12   // Використання useEffect для завантаження користувача з Local Storage при завантаженні компонента
13   useEffect(() => {
14     const result = getAuthUserFromLocalStorage("user");
15     if (result.Id != null && user.Id == null) {
16       setUser(new AuthUser(result.Id, result.Role));
17     }
18   }, [user])
19
20   // Використання i18n для багатомовності
21   const { t, i18n } = useTranslation();
22
23   // Функція для зміни мови
24   const changeLanguage = (lng?: string | undefined) => {
25     i18n.changeLanguage(lng);
26   };
27
28   return (
29     <div className={styles.container}>
30       <BrowserRouter>
31         <header className={styles.header}>
32           <button className={styles.button} style={{ minWidth: "200px" }} onClick={() => changeLanguage(i18n.language === 'en' ? 'ua' : 'en')}>
33             {t('router.switchButtonText')}
34           </button>
35           {user.Role != UserRole.Unauthorized && (
36             <div className={styles.buttonContainer}>
37               <button className={styles.button} onClick={logout}>{t('router.logoutButtonText')}</button>
38             </div>
39           )}
40         </header>
41         <div className={styles.content}>
42           <Routes>
43             <Route path="/" element={<App user={user} setUser={setUser} />} />
44             <Route path="/sheep/:sheepId" element={<SheepMainPage user={user} setUser={setUser} />} />
45             <Route path="/feed/:feedId" element={<FeedPage user={user} setUser={setUser} />} />
46             <Route path="/create/feed-supply/:feedId" element={<CreateFeedSupplyForm user={user} setUser={setUser} />} />
47             <Route path="/shepherd/create" element={<AdminBaseForm user={user} setUser={setUser} entityType="Shepherd" />} />
48             <Route path="/shepherd/edit/:entityId" element={<AdminBaseForm user={user} setUser={setUser} entityType="Shepherd" />} />
49             <Route path="/storekeeper/create" element={<AdminBaseForm user={user} setUser={setUser} entityType="Storekeeper" />} />
50             <Route path="/storekeeper/edit/:entityId" element={<AdminBaseForm user={user} setUser={setUser} entityType="Storekeeper" />} />
51             <Route path="/sheep/create" element={<AdminBaseForm user={user} setUser={setUser} entityType="Sheep" />} />
52             <Route path="/sheep/edit/:entityId" element={<AdminBaseForm user={user} setUser={setUser} entityType="Sheep" />} />
53             <Route path="/sheep/reassign-shepherd/:sheepId" element={<ReassignFormForSheep user={user} setUser={setUser} entityType="Shepherd" />} />
54             <Route path="/sheep/reassign-temperature-scanner/:sheepId" element={<ReassignFormForSheep user={user} setUser={setUser} entityType="TemperatureScanner" />} />
55             <Route path="/feed/create" element={<AdminBaseForm user={user} setUser={setUser} entityType="Feed" />} />
56             <Route path="/feed/edit/:entityId" element={<AdminBaseForm user={user} setUser={setUser} entityType="Feed" />} />
57             <Route path="/breed/create" element={<AdminBaseForm user={user} setUser={setUser} entityType="Breed" />} />
58             <Route path="/breed/edit/:entityId" element={<AdminBaseForm user={user} setUser={setUser} entityType="Breed" />} />
59             <Route path="/temperature-scanner/create" element={<AdminBaseForm user={user} setUser={setUser} entityType="TemperatureScanner" />} />
60             <Route path="/temperature-scanner/edit/:entityId" element={<AdminBaseForm user={user} setUser={setUser} entityType="TemperatureScanner" />} />
61             <Route path="*" element={<div>Not Found 404</div>} />
62           </Routes>
63         </div>
64       </BrowserRouter>
65       <footer className={styles.footer}>
66         © 2024 Wool Farm Management System
67       </footer>
68     </div>
69   )
70 };

А.2 Файл SheepService.ts

1  export class SheepService implements ISheepService<SheepDetailsVM> {
2      // Статичні URL-адреси для запитів до API
3      private static SHEEP_URLS = {
4          GET_ALL: `${API_URL}/sheep`, // URL для отримання всіх овець
5          GET_BY_ID: (id: number) => `${API_URL}/sheep/${id}`, // URL для отримання вівці за ідентифікатором
6          CREATE: `${API_URL}/sheep/create`, // URL для створення нової вівці
7          DELETE: (id: number) => `${API_URL}/sheep/delete/${id}`, // URL для видалення вівці за ідентифікатором
8          UPDATE: `${API_URL}/sheep/update`, // URL для оновлення вівці
9          GET_ALL_VMS_BY_SHEPHERD_ID: (id: number) => `${API_URL}/sheep/shepherd/${id}`, // URL для отримання всіх моделей представлення овець за ідентифікатором пастуха
10         GET_DETAILS_BY_ID: (id: number) => `${API_URL}/sheep/details/${id}`, // URL для отримання детальної інформації про вівцю за ідентифікатором
11         CHANGE_SHEPHERD: (sheepId: number) => `${API_URL}/sheep/change-shepherd/${sheepId}`, // URL для зміни пастуха у вівці
12         CHANGE_TEMPERATURE_SCANNER: (sheepId: number) => `${API_URL}/sheep/change-temperature-scanner/${sheepId}` // URL для зміни температурного сканера у вівці
13     }
14 
15     // Метод для створення нової вівці
16     async create(item: Sheep): Promise<Sheep> {
17         const response = await axios.post<Sheep>(SheepService.SHEEP_URLS.CREATE, item);
18         return response.data;
19     }
20 
21     // Метод для видалення вівці за ідентифікатором
22     async delete(itemId: number): Promise<void> {
23         await axios.delete(SheepService.SHEEP_URLS.DELETE(itemId));
24     }
25 
26     // Метод для оновлення існуючої вівці
27     async update(item: Sheep): Promise<Sheep> {
28         const response = await axios.put<Sheep>(SheepService.SHEEP_URLS.UPDATE, item);
29         return response.data;
30     }
31 
32     // Метод для отримання всіх овець
33     async getAll(): Promise<Sheep[]> {
34         const response = await axios.get<Sheep[]>(SheepService.SHEEP_URLS.GET_ALL);
35         return response.data;
36     }
37 
38     // Метод для отримання вівці за ідентифікатором
39     async getById(id: number): Promise<Sheep | null> {
40         const response = await axios.get<Sheep | null>(SheepService.SHEEP_URLS.GET_BY_ID(id));
41         return response.data;
42     }
43 
44     // Метод для отримання всіх моделей представлення овець за ідентифікатором пастуха
45     async getAllVMsByShepherdId(id: number): Promise<SheepVM[]> {
46         const response = await axios.get<[]>(SheepService.SHEEP_URLS.GET_ALL_VMS_BY_SHEPHERD_ID(id));
47         const vms: SheepVM[] = [];
48         response.data.map(sheep => {
49             //@ts-ignore
50             vms.push(new SheepVM(sheep.id, sheep.breed, sheep.sex, sheep.birth_date, sheep.last_feeding_timestamp, sheep.last_shearing_timestamp));
51         });
52         return vms;
53     }
54 
55     // Метод для отримання детальної інформації про вівцю за ідентифікатором
56     async getDetailsById(id: number): Promise<SheepDetailsVM | null> {
57         const response = await axios.get(SheepService.SHEEP_URLS.GET_DETAILS_BY_ID(id));
58         const sheepDetails = response.data;
59         if (sheepDetails) {
60             //@ts-ignore
61             return new SheepDetailsVM(
62                 sheepDetails.id,
63                 sheepDetails.breed,
64                 sheepDetails.breed_info,
65                 sheepDetails.sex,
66                 sheepDetails.birth_date,
67                 sheepDetails.weight,
68                 sheepDetails.feed_id,
69                 sheepDetails.feed_name,
70                 sheepDetails.required_feed_amount,
71                 sheepDetails.available_feed_amount,
72                 sheepDetails.last_feeding_timestamp,
73                 sheepDetails.last_shearing_timestamp,
74                 sheepDetails.temperature
75             );
76         }
77         return null;
78     }
79 
80     // Метод для зміни пастуха у вівці
81     async changeShepherd(sheepId: number, changeId: number | null): Promise<void> {
82         await axios.patch<void>(SheepService.SHEEP_URLS.CHANGE_SHEPHERD(sheepId), { change_id: changeId });
83     }
84 
85     // Метод для зміни температурного сканера у вівці
86     async changeTemperatureScanner(sheepId: number, changeId: number | null): Promise<void> {
87         await axios.patch<void>(SheepService.SHEEP_URLS.CHANGE_TEMPERATURE_SCANNER(sheepId), { change_id: changeId });
88     }
89 }

А.3 Модуль helpers.ts

1  // Функція для конвертації мітки часу в дату у форматі "гг:хх дд.мм.рррр"
2  export const timestampToDate = (timestamp: number): string => {
3    let date = new Date(timestamp * 1000);
4    let hours = date.getHours().toString().padStart(2, '0');
5    let minutes = date.getMinutes().toString().padStart(2, '0');
6    let day = date.getDate();
7    let month = (date.getMonth() + 1).toString().padStart(2, '0');
8    let year = date.getFullYear();
9    return `${hours}:${minutes} ${day}.${month}.${year}`;
10 }
11 
12 // Функція для збереження авторизованого користувача в Local Storage
13 export const saveAuthUserToLocalStorage = (key: string, value: AuthUser) => {
14   try {
15       const serializedValue = JSON.stringify({
16           Id: value.Id,
17           Role: value.Role
18       });
19       localStorage.setItem(key, serializedValue);
20   } catch (error) {
21       console.error('Error saving to Local Storage:', error);
22   }
23 };
24 
25 // Функція для отримання авторизованого користувача з Local Storage
26 export const getAuthUserFromLocalStorage = (key: string): AuthUser => {
27   try {
28       const serializedValue = JSON.parse(localStorage.getItem(key) as string);
29       if (serializedValue != null) {
30           //@ts-ignore
31           return new AuthUser(serializedValue.Id, serializedValue.Role);
32       }
33       return new AuthUser(null, UserRole.Unauthorized);
34   } catch (error) {
35       console.error('Error retrieving from Local Storage:', error);
36       return new AuthUser(null, UserRole.Unauthorized);
37   }
38 };
39 
40 // Функція для хешування пароля
41 export const hashPassword = async (password: string) => {
42   const encoder = new TextEncoder();
43   const data = encoder.encode(password);
44 
45   const hashBuffer = await crypto.subtle.digest('SHA-256', data);
46   const hashArray = Array.from(new Uint8Array(hashBuffer));
47   const hashedPassword = hashArray.map((byte) => ('00' + byte.toString(16)).slice(-2)).join('');
48 
49   return hashedPassword;
50 };
51 
52 // Функція для перевірки користувача та навігації
53 export const useEffectUser = (dependency: AuthUser, navigate: NavigateFunction) => {
54   useEffect(() => {
55       const result = getAuthUserFromLocalStorage("user");
56       if (result.Id == null) {
57           navigate("/");
58       }
59   }, [dependency])
60 };
61 
62 // Функція для обробки зміни елементів
63 export const handleElementChange = (e: React.ChangeEvent<HTMLInputElement> | React.ChangeEvent<HTMLSelectElement> | React.ChangeEvent<HTMLTextAreaElement>, setChanges: (value: React.SetStateAction<any>) => void) => {
64   setChanges(e.target.value);
65 };
66 
67 // Функція для обчислення часу в днях з мітки часу
68 export const timeInDays = (timestamp: number | null): number => {
69   if (timestamp == null) {
70       return Infinity;
71   }
72   const difference = (new Date().getTime() - timestamp * 1000);
73   const days = difference / 1000 / 3600 / 24;
74   return Math.floor(days);
75 };
