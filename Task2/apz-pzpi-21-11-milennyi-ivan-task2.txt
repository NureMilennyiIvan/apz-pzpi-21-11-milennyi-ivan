1 ОПИС АРХІТЕКТУРИ СИСТЕМИ

Програмна система призначена для контролю роботи вовняної ферми. Вона реалізована на мові програмування Rust з використанням фреймворку ActixWeb для створення REST API, що забезпечує комунікацію між клієнтськими частинами та сервером. Система використовує HTTP протокол для передачі даних, причому кожен API метод має свою адресу та параметри. Дані, що надходять на сервер або відправляються з нього за допомогою HTTP, представлені у форматі JSON. REST API було обрано завдяки його простоті в реалізації та масштабованості. Така архітектура дозволяє легко інтегрувати різні клієнтські частини, включаючи веб-клієнт, мобільний додаток та пристрої IoT.
Фронтенд-частина системи, реалізована за допомогою фреймворку React і збирача Vite, взаємодіє з сервером через REST API, отримуючи та відправляючи дані у форматі JSON. Це забезпечує швидку та зручну розробку інтерфейсів користувача, які можуть динамічно оновлюватись відповідно до стану даних на сервері.
Мобільний додаток, розроблений для платформи Android, використовує аналогічну схему взаємодії з сервером через REST API. Це дозволяє користувачам отримувати актуальну інформацію та надсилати дані з будь-якого місця, забезпечуючи мобільність та доступність управління фермою.
Пристрої IoT, які використовуються для моніторингу температури та інших параметрів, також інтегруються з системою через REST API. Вони відправляють зібрані дані на сервер, де вони обробляються та зберігаються, що дозволяє забезпечити оперативний контроль за станом тварин та умовами їх утримання.
Для збереження інформації, що стосується працівників, овець, кормів, записів, сканерів та іншої інформації було обрано систему управління бази даних MySQL. MySQL Server на якому буде запущена база даних буде знаходитись на окремому сервері.

2 ПОБУДОВА ДІАГРАМИ РОЗГОРТАННЯ

На діаграмі розгортання (див. рисунок 2.1) зображена структура програмної системи для контролю роботи вовняної ферми, яка складається з наступних компонентів:
- **Backend Server**: Реалізований з використанням фреймворку Actix Web. Містить такі компоненти:
  - **Services**: Обробляє бізнес-логіку та взаємодіє з базою даних через пакет `sqlx`.
  - **Endpoints**: Відповідає за маршрутизацію HTTP-запитів, викликає методи сервісів, управляє помилками та надсилає відповіді клієнтам.
- **Database Server**: На окремому сервері розміщена база даних MySQL, яка зберігає інформацію про працівників, овець, корма, записи сканерів та інші дані. З'єднання з серверною частиною відбувається через протокол TCP/IP.
- **Web Server**: Веб-сервер, на якому розгорнуто фронтенд-частину програми, реалізовану за допомогою фреймворку React та збирача Vite. Містить такі компоненти:
  - **React Components**: Відповідають за відображення інтерфейсу користувача.
  - **Services**: Взаємодіють з серверною частиною через HTTP-запити.
- **Temperature Scanner (IoT)**: Пристрій IoT, що збирає дані про температуру та відправляє їх на сервер через HTTP. Складається з таких компонентів:
  - **Main Loop**: Основний цикл роботи пристрою, який збирає та передає дані.
- **Android Mobile**: Мобільний додаток для платформи Android, який забезпечує мобільний доступ до системи. Містить такі компоненти:
  - **Services**: Взаємодіють з серверною частиною через HTTP-запити для отримання та відправки даних.
Ця архітектура забезпечує зручну та ефективну взаємодію між усіма компонентами системи, дозволяючи забезпечити безперервний контроль та управління фермою. Використання HTTP-протоколу та REST API дозволяє легко масштабувати систему та інтегрувати нові клієнтські частини.

3 ОПИС АРХІТЕКТУРИ СЕРВЕРНОЇ ЧАСТИНИ

Серверна частина була розбита на блоки за для зручності розробки та подальшої підтримки програми. Було виділено наступні компоненти: models, view_modles, json_structures, db, endpoints, configs.  
Модуль models містить собой структури з полями, які представляють собою сутності в базі даних.
Модуль view_models містить структури, які дозволяють представити дані у форматі, який потрібно відправити на клієнтську частину, наприклад на веб-клієнт або мобільний додаток. Ці структури призначені для перетворення даних з формату бази даних у формат, зручний для користувача, забезпечуючи тим самим правильне відображення інформації на стороні клієнта.
Модуль json_structures містить структури, які використовуються для представлення тіла деяких POST або PATCH, наприклад це може бути структура яка містить дані для авторизації.
Модуль db складається з двох підмодулів, а саме services та traits. Створення цього модулю є результатом використання патерну Repository. Модуль traits містить в собі трейти, це аналог інтерфейсів з об’єктно орієнтованих мов, що описують методи, які будуть реалізовані для сервісів. Використання трейтів спрощує розробку, оскільки дозволяє створити рівень абстракції між реалізацією метода та модулем, який використовує метод. У модулі services знаходяться сервіси, які реалізовують свої трейти та їх методи для взаємодії з даними. Кожен сервіс працює з однією конкретною сутністю в базі даних та її представленням з модуля models. Методи сервісів містять SQL запити, які взаємодіють з базою даних, та бізнес-логіку для роботи з даними з бази даних.
Модуль endpoints містить в собі методи, які викликають методи сервісів для взаємодії з даними, управляють помилками, надсилають відповіді клієнту та виконують логування. Ці методи забезпечують маршрутизацію запитів, обробку даних і відправку відповідей, гарантуючи правильну взаємодію між клієнтською та серверною частинами програми.
Модуль configs містить файли конфігурації, у яких знаходяться функції, які реєструють методи з сервісів та їх адреси у сервері. Також цей модуль містить код конфігурації Swagger UI та логування. Конфігурація Swagger UI дозволяє автоматично генерувати документацію для API, що значно полегшує тестування та інтеграцію системи. Логування забезпечує запис важливих подій і помилок, що сприяє легкому моніторингу та налагодженню роботи системи. 
Щоб серверний додаток міг взаємодіяти з базою даних MySQL, було використано пакет sqlx. Цей пакет дозволяє відправляти запити до бази даних та автоматично обробляє серіалізацію та десеріалізацію структур під час запису та зчитування даних з бази.
Для забезпечення зручності використання серверної програми адміністратором бази даних, було вирішено інтегрувати Swagger. Swagger надає графічний інтерфейс, який спрощує процес розгортання та підтримки REST API. Крім того, використання Swagger дозволило уникнути написання тестів, оскільки цей інструмент забезпечує просте та швидке тестування методів і демонстрацію їхньої роботи.
Також було прийнято рішення додати можливість логування з використанням пакет flexi_logger. Цей пакет надає можливість гнучко налаштувати логування, що робить його зручним для використання у різних середовищах, таких як розробка, тестування та продакшн. flexi_logger дозволяє налаштовувати рівні логування, такі як debug, info, warn та error, що допомагає фільтрувати логування відповідно до важливості повідомлень. Крім того, пакет підтримує ротацію логів, тобто автоматичне створення нових файлів після досягнення певного розміру або за певний період, що забезпечує зручність у зберіганні та аналізі логів. Він також дозволяє легко змінювати формат логів, додаючи до них часові мітки, рівні логування та іншу корисну інформацію. Використання flexi_logger забезпечує надійне та зручне логування, що є важливим аспектом для підтримки та моніторингу роботи системи.
У методі main (див. Додаток А пункт А.1) програми відбувається налаштування та запуск серверу. Спочатку завантажуються змінні середовища, які містять конфігураційну інформацію, таку як IP-адреса, порт і рядок підключення до бази даних. Ці змінні середовища використовуються для налаштування параметрів серверу і підключення до бази даних MySQL. Після цього створюється контекст бази даних, який використовується для створення різних сервісів, таких як BreedService, FeedService, FeedSupplyService, FeedingLogService, ShearingLogService, SheepService, ShepherdService, StorekeeperService та TemperatureScannerService. Кожен з цих сервісів відповідає за взаємодію з конкретною сутністю в базі даних. Далі налаштовується логування для відстеження подій і помилок. Основна частина методу main включає налаштування та запуск HTTP сервера. Створюється новий додаток App, в який додаються всі сервіси, налаштовуються CORS, та реєструється Swagger UI для автоматичного генерування документації API. Налаштування CORS, містять перелік адресс, які можуть мати доступ до серверу, а також типи методів з хедерами, які можуть поступати на сервер та бути прийнятими. Сервер прив'язується до вказаної IP-адреси та порту і запускається в асинхронному режимі, забезпечуючи можливість обробки одночасних запитів від клієнтів.
Тестування проводилося вручну за допомогою Swagger. Використання Swagger зробило процес тестування швидким і зручним, а також дозволило значно зекономити час, який інакше був би витрачений на написання тестів або виклики методів через термінал. Функціональне тестування полягало в надсиланні HTTP-запитів з різними наборами даних на сервер та виклику методів, зареєстрованих за вказаними в запитах адресами.
Для розуміння логіки та архітектури системи розглянемо структуру сервісу «SheepService», оскількі він має найбільше функціоналу, та імплементацію методів трейтів «Service» та «SheepManage» (див. Додаток А пункт А.2). Структура «SheepService» містить поле для, яке повинно надавати зв’язок до каналу отримання даних. Тип цього поле не визначений, тому цей сервіс може підтримувати будь-яку реалізацію. В даному випадку використовується пул зв’язку з базою даних MySQL. Ця структура була створена, щоб інкапсулювати бізнес логіку у методі, до яких буде можливо звернутись через цю структуру. Цей патерн проектування називається Service Layer. Цей патерн допомагає створювати добре структуровані, підтримувані та масштабовані додатки з чітким розділенням бізнес-логіки від інших частин системи.
Перший трейт, який імплементує «SheepService» це «Service». Цей трейт є базовим для всіх сервісів, тому його імплементують всі сервіси. Для його імплементації потрібно реалізувати методи: «new», «create», «delete», «update», «get_all», «get_by_id». Метод «new» створює новий екземпляр сервісу з переданим пулом з'єднань; метод «create» відповідає за створення нової вівці у базі даних; метод «delete» видаляє вівцю за її ідентифікатором; метод «update» оновлює інформацію про вівцю; метод «get_all» отримує всі овець; метод «get_by_id» отримує вівцю за її ідентифікатором.
Також для імплементації трейту «Service» потрібно визначити асоційовані типи, а саме «Model» — модель з якою будуть працювати методи, «Error» — помилка яку будуть повертати методи, «ViewModel» — модель представлення яку будуть повертати методи. В цій імплементації ці типи визначено як: «Model» — «Sheep», «Error» — «ServiceError», «ViewModel» — «SheepVM». «Sheep» це структура, яка  представляє сутність вівці з бази даних, та містить ідентичні з нею поля. «SheepVM» це модель представлення вівці, вона містить id вівці, назву породи, стать, дату народження та дати останніх стрижки та годування. «ServiceError» це перерахування, яке представляю собою типи помилок, до яких приводяться всі помилки, які можуть виникнути при роботі програмі.
Другий трейт, який імплементує «SheepService», це «SheepManage», який є розширенням для трейту «Service». Тобто імплементація «SheepManage» неможлива без «Service». Це дає змогу використовувати асоційовані типи з «Service» у «SheepManage». Цей трейт спеціалізується на управлінні даними, пов'язаними з вівцями, і додає додаткові методи, специфічні для цього сервісу. Для його імплементації потрібно реалізувати методи: «get_all_vms_by_shepherd_id», «get_details_by_id», «change_shepherd», «change_temperature_scanner». Метод «get_all_vms_by_shepherd_id» отримує всі моделі представлення овець за ідентифікатором пастуха; метод «get_details_by_id» отримує детальну інформацію про вівцю за її ідентифікатором; метод «change_shepherd» змінює пастуха для вівці; метод «change_temperature_scanner» змінює сканер температури для вівці. 
Також для імплементації трейту «SheepManage» потрібно визначити асоційовані типи, а саме «SheepDetails» — структура, з якою буде працювати метод «get_details_by_id». В цій імплементації ці типи визначено як: «SheepDetails» — «SheepDetailsVM». «SheepDetailsVM» це структура, яка  містить в собі детальну інформацію про вівцю. 
Розглянемо ендпоінти з підмодуля sheep_endpoints.rs модулю endpoints (див. Додаток А пункт А.3). Цей модуль містить в собі тільки методи, які мають в аргументах об’єкт типу «SheepService». Деякі методи також приймають моделі або JSON структури для отримання тіла запиту або параметрів. Кожен з цих методів викликає за допомогою сервісу один з методів реалізованих цим сервісом, а потім повертає результат його роботи клієнту. 
Метод «sheep_get_all» очікує HTTP GET запити за адресою /sheep і використовує метод «get_all()» сервісу для отримання всіх овець із бази даних. Метод «sheep_get_by_id» очікує HTTP GET запити за адресою /sheep/{id} і використовує метод «get_by_id()» сервісу для отримання вівці за її ID, який передається в шляху запиту. Метод «sheep_get_details_by_id» очікує HTTP GET запити за адресою /sheep/details/{id} і використовує метод «get_details_by_id()» сервісу для отримання детальної інформації про вівцю за її ID. Метод «sheep_get_all_vms_by_shepherd_id» очікує HTTP GET запити за адресою /sheep/shepherd/{id} і використовує метод «get_all_vms_by_shepherd_id()» сервісу для отримання всіх моделей представлення овець за ідентифікатором пастуха.
Метод «sheep_create» очікує HTTP POST запити за адресою /sheep/create і використовує метод «create()» сервісу, отримуючи дані для створення нової вівці у тілі запиту. Метод «sheep_update» очікує HTTP PUT запити за адресою /sheep/update і використовує метод «update()» сервісу, отримуючи дані для оновлення інформації про вівцю у тілі запиту. Метод «sheep_change_shepherd» очікує HTTP PATCH запити за адресою /sheep/change-shepherd/{id} і використовує метод «change_shepherd()» сервісу, отримуючи ідентифікатор нового пастуха для зміни у тілі запиту та ідентифікатор вівці в шляху запиту. Метод «sheep_change_temperature_scanner» очікує HTTP PATCH запити за адресою /sheep/change-temperature-scanner/{id} і використовує метод «change_temperature_scanner()» сервісу, отримуючи ідентифікатор нового сканера температури для зміни у тілі запиту та ідентифікатор вівці в шляху запиту. Метод «sheep_delete» очікує HTTP DELETE запити за адресою /sheep/delete/{id} і використовує метод «delete()» сервісу, отримуючи ID вівці для видалення в шляху запиту. 
Для валідації тіла запиту, логування та надсилання відповіді ендпоінти використовують функції за підмодуля utils.rs модуля endpoints (див. Додаток А пункт А.4). Цей модуль містить функції «validate_json_body», «send_service_result», «send_service_message». Функція «validate_json_body» відповідає за валідацію JSON тіла запиту. Якщо валідація проходить успішно, функція повертає структуру, перетворену з JSON. У випадку помилки валідації функція повертає HTTP відповідь із статусом BadRequest та повідомленням про помилку. Це дозволяє забезпечити, що всі дані, які надходять у запитах, відповідають вимогам і можуть бути безпечно оброблені далі.
Функція «send_service_result» використовується для надсилання результату роботи сервісу. У випадку успішного виконання функція повертає HTTP відповідь із статусом Ok та результатом у форматі JSON. Якщо виникає помилка, функція повертає HTTP відповідь із статусом InternalServerError та повідомленням про помилку. Це дозволяє централізовано обробляти результати виконання сервісних методів і повертати відповідні відповіді клієнтам.
Функція «send_service_message» призначена для надсилання повідомлень про результат роботи сервісу. У випадку успішного виконання функція повертає HTTP відповідь із статусом Ok та повідомленням у форматі JSON. Якщо виникає помилка, функція повертає HTTP відповідь із статусом InternalServerError та повідомленням про помилку. Це забезпечує єдиний підхід до надсилання повідомлень про результат виконання дій, що підвищує зручність налагодження та підтримки коду.
Розглянемо функцію конфігурацію «sheep_configure» з підмодуля configure.rs модулю configs (див. Додаток А пункт А.5). Виклик цієї функції в методі main реєструє всі ендпоінти з модуля sheep_endpoints.rs та робить їх доступними за вказаними адресами. 
Розгляд інших 8 сервісів не є необхідним оскільки вони реалізовані за тією ж архітектурою. Кожен сервіс імплементує трейт «Service» та має свій трейт для специфічних методів. Також для кожного сервісу є відповідний підмодуль у модулі endpoints та функція конфігурації в модулі configure.rs. 

4 ПОБУДОВА ДІАГРАМИ ПРЕЦЕДЕНТІВ

Предметна область включає п’ять типів користувачів. Перший тип — це неавторизований користувач, який, використовуючи веб-клієнт або мобільний додаток, має можливість тільки авторизуватись. Другий тип – це вівчар, який, використовуючи веб-клієнт або мобільний додаток, має можливість взаємодіяти з серверною частиною системи, користуватися її функціями та переглядати необхідну інформацію про овець, а також відмічати годування та стрижки. Третій тип – це комірник, який, також за допомогою веб-клієнта або мобільного додатку, може взаємодіяти з серверною частиною та виконувати свої обов'язки. Він відповідає за контроль ресурсів ферми, таких як кількість кормів і їх витрати, а також відмічає нові поставки кормів. Четвертий тип користувача – це фермер або бізнес-адміністратор, який через веб-клієнт може маніпулювати певними даними та процесами за допомогою графічного інтерфейсу. Основні функції цього типу користувача включають додавання нових комірників, вівчарів, овець, порід, кормів та сканерів температури. Крім того, фермер визначає, за якими вівцями буде доглядати вівчар, та який температурний сканер буде використовуватися для вимірювання температури овець. П’ятий тип користувача – це адміністратор бази даних, який має змогу безпосередньо взаємодіяти з серверною частиною та базою даних системи. Він має доступ до всіх методів маніпулювання даними, забезпечуючи їх цілісність та актуальність, що є критично важливим для стабільної роботи системи. Крім того, в системі використовується температурний сканер, який здатний вимірювати температуру овець та зберігати ці дані завдяки інтеграції з серверною частиною системи. Інформація, зібрана сканером, допомагає забезпечити здоров'я тварин та своєчасно реагувати на будь-які відхилення від нормальних параметрів. Таким чином, предметна область охоплює різні аспекти функціонування вовняної ферми, забезпечуючи інтеграцію та ефективну взаємодію між усіма типами користувачів та компонентами системи. Це сприяє покращенню управління фермою, підвищенню продуктивності та створенню оптимальних умов для догляду за вівцями.
Першим типом користувача є неавторизований користувач. Йому доступна лише функція авторизації. Описані функціональні потреби повністю відповідають необхідним для неавторизованого користувача функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 4.1.
Вівчар є одним з двох основних типів користувачів для даної предметної області. Він повинен мати доступ до списку овець, які закріплені за ним, списку порід та кормів, що знаходяться на фермі. Вівчар також повинен мати змогу переглядати детальну інформацію про кожну з овець, які закріплені за ним, включаючи їхню температуру та дати останніх стрижок і годувань. Крім того, вівчар повинен мати доступ до історії записів про годування та стрижки овець. Важливо, щоб вівчар мав змогу додавати нові записи у випадку, якщо він підстриг або погодував вівцю. Описані функціональні потреби повністю відповідають необхідним для вівчаря функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 4.2.                 
Комірник є ще одним типом користувачів системи, призначеним для управління ресурсами ферми. Комірник має доступ до функції перегляду списку кормів, що є основною функцією. Також комірник може створювати відмітки про поставку корму, що є важливою частиною підтримання актуальної інформації про наявність ресурсів на фермі. Крім того, комірник може переглядати список поставок корму. Це дозволяє йому відстежувати історію поставок та планувати майбутні потреби. Ще одна функція – це перегляд списку годувань кормом, що допомагає комірнику контролювати витрати кормів і забезпечувати, щоб усі тварини отримували необхідне харчування. Описані функціональні потреби повністю відповідають необхідним для комірника функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 4.3.
Фермер (бізнес-адміністратор) є ключовим користувачем системи, який має доступ до широкого спектру функцій через адмін-панель. Основною функцією фермера є доступ до адмін-панелі, що дозволяє йому виконувати різні операції, такі як перегляд, додавання, редагування та видалення даних. Через адмін-панель фермер може управляти всіма аспектами ферми. Він має можливість переглядати історію годувань, стрижок і поставок кормів, а також видаляти ці записи при необхідності. Фермер також може переглядати список усіх комірників, вівчарів та овець. Він має змогу додавати нових комірників та вівчарів, редагувати їх або видаляти. Щодо овець, фермер може переглядати інформацію про них, додавати нових овець, редагувати та видаляти їх. Крім того, він має доступ до інформації про всі породи овець на фермі, кормів та температурних сканерів. Це дозволяє фермеру додавати нові корми та породи, редагувати існуючі записи та видаляти їх. Додатково фермер може переглядати інформацію про всі температурні сканери, а також додавати, редагувати та видаляти їх. Важливою функцією є можливість призначати сканери для вимірювання температури конкретних овець, а також призначати вівчарів для догляду за конкретними овець. Описані функціональні потреби повністю відповідають необхідним для фермера (бізнес-адміністратора) функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 4.4.
Адміністратор бази даних є ще одним важливим типом користувачів системи, який повинен мати прямий доступ до серверного додатку, щоб мати повний доступу до усіх функцій та бази даних. Адміністратор бази даних має можливість здійснювати різні операції з даними. В першу чергу, він володіє повним доступом до бази даних, що дозволяє йому виконувати основні дії, такі як додавання, редагування, перегляд та видалення даних. Функція додавання дозволяє адміністратору вводити нові записи до бази даних, забезпечуючи актуальність та повноту інформації. Редагування дає змогу змінювати існуючі записи, вносячи необхідні корективи та оновлення. Перегляд забезпечує доступ до даних для аналізу та перевірки їхньої точності. Видалення дає змогу видаляти застарілі або некоректні записи, підтримуючи чистоту та релевантність бази даних. Описані функціональні потреби повністю відповідають необхідним для адміністратора функціям, вони проілюстровані у вигляді діаграми прецедентів на рисунку 4.5.

5 ПОБУДОВА ER-ДІАГРАМИ

Спираючись на отриману модель предметної області, була побудована ER-модель бази даних (див. рисунок 5.1), яка зможе зберігати всю інформацію, необхідну для реалізації описаної функціональності.
Було виділено 9 сутностей: породи, поставки кормів, записи годувань, корми, записи стрижок, вівці, вівчарі, комірники, температурні сканери.
Виділені сутності отримали наступні атрибути:
- **Породи**: id, feed_id, назва, інформація про породу. Первинний ключ: id. Зовнішній ключ: feed_id (має бути унікальним).
- **Поставки кормів**: id, комірник_id, корм_id, кількість корму, часова мітка коли була зроблена поставка. Первинний ключ: id. Зовнішні ключі: корм_id, комірник_id (може бути відсутнім).
- **Записи годувань**: id, вівця_id, вівчар_id, корм_id, кількість витраченого корму, часова мітка коли було відмічено годування. Первинний ключ: id. Зовнішні ключі: вівця_id, корм_id, вівчар_id (може бути відсутнім).
- **Корми**: id, кількість корму, назва, калорійність, жири, білки, вуглеводи. Первинний ключ: id.
- **Записи стрижок**: id, вівця_id, вівчар_id, кількість отриманої вовни, часова мітка коли була відмічена стрижка. Первинний ключ: id. Зовнішні ключі: вівця_id, вівчар_id (може бути відсутнім).
- **Вівчарі**: id, ім’я користувача, пароль, ім’я, прізвище. Первинний ключ: id.
- **Комірники**: id, ім’я користувача, пароль, ім’я, прізвище. Первинний ключ: id.
- **Температурні сканери**: id, пароль, температура. Первинний ключ: id.
- **Вівці**: id, вівчар_id, порода_id, сканер_id, часова мітка дати народження, стать, вага. Первинний ключ: id. Зовнішні ключі: вівчар_id (може бути відсутнім), порода_id, сканер_id (може бути відсутнім або має бути унікальним).
Позначимо зв’язки між сутностями:
- "Породи - корми" – тип зв’язку “один до одного”, оскільки кожна порода має асоційований корм.
- "Корми - поставки кормів" – тип зв’язку “один до багатьох”, оскільки для кожного корму може бути багато поставок.
- "Комірники - поставки кормів" – тип зв’язку “один до багатьох”, кожен комірник може обробляти багато поставок.
- "Вівці - записи годувань" – тип зв’язку “один до багатьох”, оскільки кожна вівця може мати багато записів годувань.
- "Вівчарі - записи годувань" – тип зв’язку “один до багатьох”, оскільки один вівчар може виконувати багато годувань.
- "Корми - записи годувань" – тип зв’язку “один до багатьох”, оскільки для кожного корму може бути багато записів годувань.
- "Вівці - записи стрижок" – тип зв’язку “один до багатьох”, оскільки кожна вівця може мати багато записів стрижок.
- "Вівчарі - записи стрижок" – тип зв’язку “один до багатьох”, оскільки кожен вівчар може виконувати багато стрижок.
- "Породи - вівці" – тип зв’язку “один до багатьох”, оскільки кожна порода може мати багато овець.
- "Вівчарі - вівці" – тип зв’язку “один до багатьох”, оскільки кожен вівчар може доглядати за багатьма вівцями.
- "Температурні сканери - вівці" – тип зв’язку “один до одного”, оскільки кожна вівця може мати асоційований температурний сканер.
Для зберігання даних про вагу було прийнято рішення використовувати грами, так як це покращує точність збереженої інформації та полегшує конвертацію у інші одиниці виміру ваги. Температура від сканера температури зберігається у десятих долях градусів цельсію, це також покращує точність збереженої інформації та полегшує конвертацію у інші одиниці виміру температури. Дати зберігаються у вигляді часових міток, що дозволяє за рахунок використання меншого обсягу пам’яті зберігати дати з точністю до секунд. Також клієнтські частини зможуть легко відображати коректну дату, враховуючи часовий пояс користувача. Такий підхід уніфікації зберігання різноформатних даних суттєво покращує інтернаціоналізацію серверу та потенційну інтерналізацію клієнтських додатків, дає можливість відображати дані як в метричній, так і в американській імперичній системах вимірювання, а також дає можливість підтримувати локальний, універсальний або будь-який інший час.

6 СПЕЦИФІКАЦІЯ REST

Цей розділ містить інформацію про REST API, створену для взаємодії з програмною системою. API реалізовано на мові програмування Rust з використанням фреймворку ActixWeb, що забезпечує масштабованість та простоту в реалізації.
Усі запити мають надсилатись за адресою, на якій працює сервер. В даному випадку це: http://127.0.0.1:8080.
Ендпоінти поділені на 9 підмодулів, тому опис REST специфікації буде також по модулях.
Перший модуль - breed_endpoints.rs, який має ендпоінти для роботи з породами. Він складається з наступних методів:
- **breed_get_all()**
  - Опис: Отримати список всіх порід.
  - Метод HTTP: GET /breed
  - Відповіді:
    - 200 OK: Успішне отримання списку порід.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **breed_get_by_id()**
  - Опис: Отримати породу за її Id.
  - Метод HTTP: GET /breed/{id}
  - Параметри URL: {id} — ідентифікатор породи.
  - Відповіді:
    - 200 OK: Успішне отримання породи за вказаними Id.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **breed_get_all_vms()**
  - Опис: Отримати список моделей представлення всіх порід.
  - Метод HTTP: GET /breed-vms
  - Відповіді:
    - 200 OK: Успішне отримання списку моделей представлення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **breed_create()**
  - Опис: Створити нову породу.
  - Метод HTTP: POST /breed/create
  - Тіло запиту: Об’єкт типу Breed.
  - Відповіді:
    - 200 OK: Повернення створеної породи.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **breed_update()**
  - Опис: Оновити інформацію про породу.
  - Метод HTTP: PUT /breed/update
  - Тіло запиту: Об’єкт типу Breed.
  - Відповіді:
    - 200 OK: Повернення оновленої породи.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **breed_delete()**
  - Опис: Видалити породу за її Id.
  - Метод HTTP: DELETE /breed/delete/{id}
  - Параметри URL: {id} — ідентифікатор породи.
  - Відповіді:
    - 200 OK: Повідомлення про видалення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
Другий модуль - feed_endpoints.rs, який має ендпоінти для роботи з кормами. Він складається з наступних методів:
- **feed_get_all()**
  - Опис: Отримати список всіх кормів.
  - Метод HTTP: GET /feed
  - Відповіді:
    - 200 OK: Успішне отримання списку кормів.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **feed_get_by_id()**
  - Опис: Отримати корм за його Id.
  - Метод HTTP: GET /feed/{id}
  - Параметри URL: {id} — ідентифікатор корму.
  - Відповіді:
    - 200 OK: Успішне отримання корму за вказаними Id.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **feed_get_all_vms()**
  - Опис: Отримати список моделей представлення всіх кормів.
  - Метод HTTP: GET /feed-vms
  - Відповіді:
    - 200 OK: Успішне отримання списку моделей представлення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **feed_create()**
  - Опис: Створити новий корм.
  - Метод HTTP: POST /feed/create
  - Тіло запиту: Об’єкт типу Feed.
  - Відповіді:
    - 200 OK: Повернення створеного корму.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **feed_update()**
  - Опис: Оновити інформацію про корм.
  - Метод HTTP: PUT /feed/update
  - Тіло запиту: Об’єкт типу Feed.
  - Відповіді:
    - 200 OK: Повернення оновленого корму.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **feed_delete()**
  - Опис: Видалити корм за його Id.
  - Метод HTTP: DELETE /feed/delete/{id}
  - Параметри URL: {id} — ідентифікатор корму.
  - Відповіді:
    - 200 OK: Повідомлення про видалення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
Третій модуль - feeding_log_endpoints.rs, який має ендпоінти для роботи з записами годувань. Він складається з наступних методів:
- **feeding_log_get_all()**
  - Опис: Отримати список всіх записів годувань.
  - Метод HTTP: GET /feeding-log
  - Відповіді:
    - 200 OK: Успішне отримання списку записів годувань.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **feeding_log_get_by_id()**
  - Опис: Отримати запис годування за його Id.
  - Метод HTTP: GET /feeding-log/{id}
  - Параметри URL: {id} — ідентифікатор запису годування.
  - Відповіді:
    - 200 OK: Успішне отримання запису годування за вказаними Id.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **feeding_log_get_all_vms_by_sheep_id()**
  - Опис: Отримати список моделей представлення всіх записів годувань за Id вівці.
  - Метод HTTP: GET /feeding-log/sheep/{id}
  - Параметри URL: {id} — ідентифікатор вівці.
  - Відповіді:
    - 200 OK: Успішне отримання списку моделей представлення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **feeding_log_get_all_vms_by_feed_id()**
  - Опис: Отримати список моделей представлення всіх записів годувань за Id корму.
  - Метод HTTP: GET /feeding-log/feed/{id}
  - Параметри URL: {id} — ідентифікатор корму.
  - Відповіді:
    - 200 OK: Успішне отримання списку моделей представлення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **feeding_log_create()**
  - Опис: Створити новий запис годування.
  - Метод HTTP: POST /feeding-log/create
  - Тіло запиту: Об’єкт типу FeedingLog.
  - Відповіді:
    - 200 OK: Повернення створеного запису годування.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **feeding_log_delete()**
  - Опис: Видалити запис годування за його Id.
  - Метод HTTP: DELETE /feeding-log/delete/{id}
  - Параметри URL: {id} — ідентифікатор запису годування.
  - Відповіді:
    - 200 OK: Повідомлення про видалення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
Четвертий модуль - feed_supply_endpoints.rs, який має ендпоінти для роботи з поставками кормів. Він складається з наступних методів:
- **feed_supply_get_all()**
  - Опис: Отримати список всіх поставок кормів.
  - Метод HTTP: GET /feed-supply
  - Відповіді:
    - 200 OK: Успішне отримання списку поставок кормів.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **feed_supply_get_by_id()**
  - Опис: Отримати поставку корму за її Id.
  - Метод HTTP: GET /feed-supply/{id}
  - Параметри URL: {id} — ідентифікатор поставки корму.
  - Відповіді:
    - 200 OK: Успішне отримання поставки корму за вказаними Id.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **feed_supply_get_all_vms()**
  - Опис: Отримати список моделей представлення всіх поставок корму.
  - Метод HTTP: GET /feed-supply-vms
  - Відповіді:
    - 200 OK: Успішне отримання списку моделей представлення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **feed_supply_get_all_vms_by_feed_id()**
  - Опис: Отримати список моделей представлення всіх поставок корму за Id корму.
  - Метод HTTP: GET /feed-supply/feed/{id}
  - Параметри URL: {id} — ідентифікатор корму.
  - Відповіді:
    - 200 OK: Успішне отримання списку моделей представлення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **feed_supply_create()**
  - Опис: Створити нову поставку корму.
  - Метод HTTP: POST /feed-supply/create
  - Тіло запиту: Об’єкт типу FeedSupply.
  - Відповіді:
    - 200 OK: Повернення створеної поставки корму.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **feed_supply_delete()**
  - Опис: Видалити поставку корму за її Id.
  - Метод HTTP: DELETE /feed-supply/delete/{id}
  - Параметри URL: {id} — ідентифікатор поставки корму.
  - Відповіді:
    - 200 OK: Повідомлення про видалення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
П’ятий модуль - shearing_log_endpoints.rs, який має ендпоінти для роботи з записами стрижок. Він складається з наступних методів:
- **shearing_log_get_all()**
  - Опис: Отримати список всіх записів стрижок.
  - Метод HTTP: GET /shearing-log
  - Відповіді:
    - 200 OK: Успішне отримання списку записів стрижок.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **shearing_log_get_by_id()**
  - Опис: Отримати запис стрижки за його Id.
  - Метод HTTP: GET /shearing-log/{id}
  - Параметри URL: {id} — ідентифікатор запису стрижки.
  - Відповіді:
    - 200 OK: Успішне отримання запису стрижки за вказаними Id.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **shearing_log_get_all_vms_by_sheep_id()**
  - Опис: Отримати список моделей представлення всіх записів стрижок за Id вівці.
  - Метод HTTP: GET /shearing-log/sheep/{id}
  - Параметри URL: {id} — ідентифікатор вівці.
  - Відповіді:
    - 200 OK: Успішне отримання списку моделей представлення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **shearing_log_create()**
  - Опис: Створити новий запис стрижки.
  - Метод HTTP: POST /shearing-log/create
  - Тіло запиту: Об’єкт типу ShearingLog.
  - Відповіді:
    - 200 OK: Повернення створеного запису стрижки.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **shearing_log_delete()**
  - Опис: Видалити запис стрижки за його Id.
  - Метод HTTP: DELETE /shearing-log/delete/{id}
  - Параметри URL: {id} — ідентифікатор запису стрижки.
  - Відповіді:
    - 200 OK: Повідомлення про видалення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
Шостий модуль - sheep_endpoints.rs, який має ендпоінти для роботи з вівцями. Він складається з наступних методів:
- **sheep_get_all()**
  - Опис: Отримати список всіх овець.
  - Метод HTTP: GET /sheep
  - Відповіді:
    - 200 OK: Успішне отримання списку овець.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **sheep_get_by_id()**
  - Опис: Отримати вівцю за її Id.
  - Метод HTTP: GET /sheep/{id}
  - Параметри URL: {id} — ідентифікатор вівці.
  - Відповіді:
    - 200 OK: Успішне отримання вівці за вказаними Id.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **sheep_get_all_vms()**
  - Опис: Отримати список моделей представлення всіх овець.
  - Метод HTTP: GET /sheep-vms
  - Відповіді:
    - 200 OK: Успішне отримання списку моделей представлення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **sheep_get_all_vms_by_shepherd_id()**
  - Опис: Отримати список моделей представлення всіх овець за Id вівчара.
  - Метод HTTP: GET /sheep/shepherd/{id}
  - Параметри URL: {id} — ідентифікатор вівчара.
  - Відповіді:
    - 200 OK: Успішне отримання списку моделей представлення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **sheep_get_details_id()**
  - Опис: Отримати детальну інформацію про вівцю за її Id.
  - Метод HTTP: GET /sheep/details/{id}
  - Параметри URL: {id} — ідентифікатор вівці.
  - Відповіді:
    - 200 OK: Успішне отримання детальної інформації про вівцю.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **sheep_create()**
  - Опис: Створити нову вівцю.
  - Метод HTTP: POST /sheep/create
  - Тіло запиту: Об’єкт типу Sheep.
  - Відповіді:
    - 200 OK: Повернення створеної вівці.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **sheep_change_shepherd()**
  - Опис: Змінити вівчаря у вівці за її Id.
  - Метод HTTP: PATCH /sheep/change-shepherd/{id}
  - Параметри URL: {id} — ідентифікатор вівці.
  - Тіло запиту: Об’єкт типу ChangeIdJson, що містить новий Id вівчаря.
  - Відповіді:
    - 200 OK: Повідомлення про успішну зміну вівчаря.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **sheep_change_temperature_scanner()**
  - Опис: Змінити температурний сканер у вівці за її Id.
  - Метод HTTP: PATCH /sheep/change-temperature-scanner/{id}
  - Параметри URL: {id} — ідентифікатор вівці.
  - Тіло запиту: Об’єкт типу ChangeIdJson, що містить новий Id сканера.
  - Відповіді:
    - 200 OK: Повідомлення про успішну зміну сканера.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **sheep_update()**
  - Опис: Оновити інформацію про вівцю.
  - Метод HTTP: PUT /sheep/update
  - Тіло запиту: Об’єкт типу Sheep.
  - Відповіді:
    - 200 OK: Повернення оновленої породи.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **sheep_delete()**
  - Опис: Видалити вівцю за її Id.
  - Метод HTTP: DELETE /sheep/delete/{id}
  - Параметри URL: {id} — ідентифікатор вівці.
  - Відповіді:
    - 200 OK: Повідомлення про видалення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
Сьомий модуль - shepherd_endpoints.rs, який має ендпоінти для роботи з вівчарями. Він складається з наступних методів:
- **shepherd_get_all()**
  - Опис: Отримати список всіх вівчарів.
  - Метод HTTP: GET /shepherd
  - Відповіді:
    - 200 OK: Успішне отримання списку вівчарів.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **shepherd_get_by_id()**
  - Опис: Отримати вівчаря за його Id.
  - Метод HTTP: GET /shepherd/{id}
  - Параметри URL: {id} — ідентифікатор вівчаря.
  - Відповіді:
    - 200 OK: Успішне отримання вівчаря за вказаними Id.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **shepherd_get_all_vms()**
  - Опис: Отримати список моделей представлення всіх вівчарів.
  - Метод HTTP: GET /shepherd-vms
  - Відповіді:
    - 200 OK: Успішне отримання списку моделей представлення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **shepherd_authorize()**
  - Опис: Авторизація вівчаря.
  - Метод HTTP: POST /shepherd/authorize
  - Тіло запиту: Об’єкт типу AuthorizeJson, що містить ім’я користувача та хеш паролю.
  - Відповіді:
    - 200 OK: Повернення результату авторизації.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **shepherd_create()**
  - Опис: Створити нового вівчаря.
  - Метод HTTP: POST /shepherd/create
  - Тіло запиту: Об’єкт типу Shepherd.
  - Відповіді:
    - 200 OK: Повернення створеного вівчаря.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **shepherd_update()**
  - Опис: Оновити інформацію про вівчаря.
  - Метод HTTP: PUT /shepherd/update
  - Тіло запиту: Об’єкт типу Shepherd.
  - Відповіді:
    - 200 OK: Повернення оновленого вівчаря.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **shepherd_delete()**
  - Опис: Видалити вівчаря за його Id.
  - Метод HTTP: DELETE /shepherd/delete/{id}
  - Параметри URL: {id} — ідентифікатор вівчаря.
  - Відповіді:
    - 200 OK: Повідомлення про видалення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
Восьмий модуль - storekeeper_endpoints.rs, який має ендпоінти для роботи з комірниками. Він складається з наступних методів:
- **storekeeper_get_all()**
  - Опис: Отримати список всіх комірників.
  - Метод HTTP: GET /storekeeper
  - Відповіді:
    - 200 OK: Успішне отримання списку комірників.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **storekeeper_get_by_id()**
  - Опис: Отримати комірника за його Id.
  - Метод HTTP: GET /storekeeper/{id}
  - Параметри URL: {id} — ідентифікатор комірника.
  - Відповіді:
    - 200 OK: Успішне отримання комірника за вказаними Id.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **storekeeper_authorize()**
  - Опис: Авторизація комірника.
  - Метод HTTP: POST /storekeeper/authorize
  - Тіло запиту: Об’єкт типу AuthorizeJson, що містить ім’я користувача та хеш паролю.
  - Відповіді:
    - 200 OK: Повернення результату авторизації.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **storekeeper_create()**
  - Опис: Створити нового комірника.
  - Метод HTTP: POST /storekeeper/create
  - Тіло запиту: Об’єкт типу Storekeeper.
  - Відповіді:
    - 200 OK: Повернення створеного комірника.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **storekeeper_update()**
  - Опис: Оновити інформацію про комірника.
  - Метод HTTP: PUT /storekeeper/update
  - Тіло запиту: Об’єкт типу Storekeeper.
  - Відповіді:
    - 200 OK: Повернення оновленого комірника.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **storekeeper_delete()**
  - Опис: Видалити комірника за його Id.
  - Метод HTTP: DELETE /storekeeper/delete/{id}
  - Параметри URL: {id} — ідентифікатор комірника.
  - Відповіді:
    - 200 OK: Повідомлення про видалення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
Дев’ятий модуль - temperature_scanner_endpoints.rs, який має ендпоінти для роботи з температурними сканерами. Він складається з наступних методів:
- **temperature_scanner_get_all()**
  - Опис: Отримати список всіх температурних сканерів.
  - Метод HTTP: GET /temperature-scanner
  - Відповіді:
    - 200 OK: Успішне отримання списку температурних сканерів.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **temperature_scanner_get_by_id()**
  - Опис: Отримати температурний сканер за його Id.
  - Метод HTTP: GET /temperature-scanner/{id}
  - Параметри URL: {id} — ідентифікатор температурного сканеру.
  - Відповіді:
    - 200 OK: Успішне отримання сканеру за вказаними Id.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **temperature_scanner_get_all_unassigned_scanners_ids()**
  - Опис: Отримати Id всіх вільних температурних сканерів.
  - Метод HTTP: GET /temperature-scanner-all-unassigned-ids
  - Відповіді:
    - 200 OK: Успішне отримання списку Id вільних сканерів.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **temperature_scanner_authenticate()**
  - Опис: Автентифікація температурного сканеру.
  - Метод HTTP: POST /temperature-scanner/authenticate/{id}
  - Параметри URL: {id} — ідентифікатор температурного сканеру.
  - Тіло запиту: Об’єкт типу TemperatureScannerAuthJson, що містить пароль для автентифікації сканеру.
  - Відповіді:
    - 200 OK: Повернення результату автентифікації.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **temperature_scanner_create()**
  - Опис: Створити новий температурний сканер.
  - Метод HTTP: POST /temperature-scanner/create
  - Тіло запиту: Об’єкт типу TemperatureScanner.
  - Відповіді:
    - 200 OK: Повернення створеного температурного сканера.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **temperature_scanner_update()**
  - Опис: Оновити інформацію про температурний сканер.
  - Метод HTTP: PUT /temperature-scanner/update
  - Тіло запиту: Об’єкт типу TemperatureScanner.
  - Відповіді:
    - 200 OK: Повернення оновлений температурний сканер.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **temperature_scanner_update_temperature()**
  - Опис: Оновити температуру сканера за його Id.
  - Метод HTTP: PATCH /temperature-scanner/update-temperature/{id}
  - Параметри URL: {id} — ідентифікатор сканеру.
  - Тіло запиту: Об’єкт типу TemperatureScannerTempJson, що містить нову температуру.
  - Відповіді:
    - 200 OK: Повідомлення про успішне оновлення температури.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
- **temperature_scanner_delete()**
  - Опис: Видалити температурний сканер за його Id.
  - Метод HTTP: DELETE /temperature-scanner/delete/{id}
  - Параметри URL: {id} — ідентифікатор температурного сканеру.
  - Відповіді:
    - 200 OK: Повідомлення про видалення.
    - 400 Bad Request: Помилка валідації або некоректний запит.
    - 500 Internal Server Error: Внутрішня помилка сервера.
Кожен модуль ендпоінтів був створений з метою забезпечення ефективної та зручної взаємодії з даними системи через REST API. Всі ендпоінти мають чітко визначені методи HTTP, параметри та тіла запитів, що дозволяє клієнтам системи виконувати необхідні операції.

7 ПОБУДОВА ДІАГРАМИ КОМПОНЕНТІВ

Діаграма компонентів (див. рисунок 7.1) відображає загальну архітектуру системи контролю роботи вовняної ферми. Основна увага на даній діаграмі приділена серверу, в той час як інші компоненти будуть розглянуті детальніше у наступних розділах.
На діаграмі зображені наступні основні компоненти системи:
Backend Server (Сервер бекенду):
Основний компонент, що забезпечує обробку даних і реалізацію бізнес-логіки програми. Сервер бекенду складається з наступних підкомпонентів:
Services (Сервіси): Реалізують бізнес-логіку і взаємодію з базою даних через SQL-запити. Вони відповідають за обробку даних і виконання операцій, необхідних для функціонування системи.
Endpoints (Кінцеві точки): Забезпечують комунікацію між клієнтами і сервером, обробляючи HTTP-запити і відповіді. Вони приймають запити від клієнтів, викликають відповідні сервіси для обробки бізнес-логіки і повертають результати назад до клієнтів.
Database Server (Сервер бази даних):
Відповідає за зберігання всієї інформації, необхідної для функціонування системи. Це включає дані про вівчарів, овець, корми, температурні сканери тощо. Сервер бази даних забезпечує надійне збереження і швидкий доступ до даних.
Mobile App (Мобільний додаток):
Клієнтський додаток для мобільних пристроїв, що дозволяє вівчарям і комірникам взаємодіяти з системою. Мобільний додаток забезпечує зручний інтерфейс для користувачів, дозволяючи їм виконувати необхідні операції на фермі.
Web Server (Веб-сервер):
Сервер, що обслуговує веб-клієнт. Веб-клієнт використовується фермером (бізнес-адміністратором) для взаємодії з системою через графічний інтерфейс. Веб-сервер забезпечує доступ до адміністративних функцій системи.
IoT (Інтернет речей):
Пристрої, такі як температурні сканери, що вимірюють і передають дані про температуру овець до серверу бекенду. Ці дані використовуються для моніторингу здоров'я овець і своєчасного реагування на відхилення від нормальних параметрів.
Взаємодія між компонентами:
Backend Server комунікує з Database Server через TCP/IP для доступу і збереження даних.
Mobile App, Web Server і IoT пристрої взаємодіють з Backend Server через HTTP, надсилаючи запити до відповідних кінцевих точок.
Endpoints на Backend Server обробляють запити, викликають відповідні сервіси для обробки бізнес-логіки і взаємодії з базою даних, і повертають результати назад до клієнтів.
Ця архітектура забезпечує модульність і масштабованість системи, що дозволяє легко додавати нові функціональні можливості і підтримувати існуючі компоненти. Детальніший розгляд компонентів системи буде проведено у наступних розділах.

ВИСНОВКИ

Під час виконання лабораторної роботи була розроблена серверна частина для програмної системи для контролю роботи вовняної ферми.

ДОДАТОК А
Серверна частина

А.1 Файл main.rs

 1  #[main]
 2  async fn main() -> io::Result<()>{
 3      // Завантаження змінних середовища
 4      dotenv().ok();
 5  
 6      // Отримання IP-адреси додатку зі змінної середовища
 7      let app_ip_bytes: Vec<u8> = env::var("APP_IP").unwrap_or_else(|_| "".to_string())
 8          .split('.')
 9          .map(|byte| byte.parse::<u8>().expect("Invalid number in APP_IP"))
10          .collect();
11      let app_ip: Ipv4Addr = Ipv4Addr::new(app_ip_bytes[0], app_ip_bytes[1], app_ip_bytes[2], app_ip_bytes[3]);
12  
13      // Отримання порту додатку зі змінної середовища
14      let app_port: u16 = env::var("APP_PORT").unwrap_or_else(|_| "".to_string())
15          .parse().expect("Invalid app port number");
16  
17      // Отримання рядка підключення до бази даних зі змінної середовища
18      let db_string = env::var("DATABASE_URL").unwrap_or_else(|_| "".to_string());
19  
20      // Створення контексту бази даних
21      let db_context: DbContextMySql<Pool<MySql>> = DbContextMySql::new(db_string).await;
22  
23      // Створення сервісів
24      let breed_service: Arc<BreedService<Pool<MySql>>> = Arc::new(BreedService::new(db_context.get_pool()));
25      let feed_service: Arc<FeedService<Pool<MySql>>> = Arc::new(FeedService::new(db_context.get_pool()));
26      let feed_supply_service: Arc<FeedSupplyService<Pool<MySql>>> = Arc::new(FeedSupplyService::new(db_context.get_pool()));
27      let feeding_log_service: Arc<FeedingLogService<Pool<MySql>>> = Arc::new(FeedingLogService::new(db_context.get_pool()));
28      let shearing_log_service: Arc<ShearingLogService<Pool<MySql>>> = Arc::new(ShearingLogService::new(db_context.get_pool()));
29      let sheep_service: Arc<SheepService<Pool<MySql>>> = Arc::new(SheepService::new(db_context.get_pool()));
30      let shepherd_service: Arc<ShepherdService<Pool<MySql>>> = Arc::new(ShepherdService::new(db_context.get_pool()));
31      let storekeeper_service: Arc<StorekeeperService<Pool<MySql>>> = Arc::new(StorekeeperService::new(db_context.get_pool()));
32      let temperature_service: Arc<TemperatureScannerService<Pool<MySql>>> = Arc::new(TemperatureScannerService::new(db_context.get_pool()));
33  
34      // Налаштування логування
35      LoggerWrapper::default();
36      info!("Server started");
37  
38      // Налаштування та запуск HTTP сервера
39      HttpServer::new(move || {
40          App::new()
41              .app_data(Data::new(breed_service.clone()))
42              .app_data(Data::new(feed_service.clone()))
43              .app_data(Data::new(feed_supply_service.clone()))
44              .app_data(Data::new(feeding_log_service.clone()))
45              .app_data(Data::new(shearing_log_service.clone()))
46              .app_data(Data::new(sheep_service.clone()))
47              .app_data(Data::new(shepherd_service.clone()))
48              .app_data(Data::new(storekeeper_service.clone()))
49              .app_data(Data::new(temperature_service.clone()))
50              .wrap(
51                  Cors::default()
52                      .allow_any_origin()
53                      .allowed_methods(vec!["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"])
54                      .allowed_headers(vec![header::AUTHORIZATION, header::ACCEPT, header::ACCESS_CONTROL_REQUEST_METHOD, header::ACCESS_CONTROL_REQUEST_HEADERS, header::ORIGIN, header::CONTENT_TYPE])
55                      .max_age(3600)
56              )
57              .wrap(Logger::default())
58              .configure(breed_configure)
59              .configure(feed_configure)
60              .configure(feed_supply_configure)
61              .configure(feeding_log_configure)
62              .configure(shearing_log_configure)
63              .configure(sheep_configure)
64              .configure(shepherd_configure)
65              .configure(storekeeper_configure)
66              .configure(temperature_scanner_configure)
67              .service(SwaggerUiWrapper::build_swagger_ui())
68      }).bind((app_ip, app_port))?.run().await
69  }

А.2 Модуль sheep_service.rs

 1  // Сервіс для управління вівцями
 2  pub(crate) struct SheepService<T>{
 3      pool: Arc<T>,
 4  }
 5  
 6  #[async_trait]
 7  impl Service<Pool<MySql>> for SheepService<Pool<MySql>> {
 8      type Model = Sheep;
 9      type Error = ServiceError;
10      type ViewModel = SheepVM;
11  
12      fn new(pool: Arc<Pool<MySql>>) -> Self {
13          SheepService { pool }
14      }
15  
16      // Функція для створення нової вівці
17      async fn create(&self, mut item: Self::Model) -> Result<Self::Model, Self::Error> {
18          query(
19              r#"
20              INSERT INTO Sheep (birth_date, breed_id, weight, sex, temperature_scanner_id, shepherd_id)
21              VALUES (?, ?, ?, ?, null, ?)
22              "#
23          )
24              .bind(item.birth_date())
25              .bind(item.breed_id())
26              .bind(item.weight())
27              .bind(item.sex())
28              .bind(item.shepherd_id())
29              .execute(&*self.pool).await
30              .map_err(|error| ServiceError::DatabaseError(error))
31              .map(|result|
32                  if result.rows_affected() == 1 {
33                      item.set_id(result.last_insert_id());
34                      Ok(item)
35                  }
36                  else{
37                      Err(ServiceError::CustomError("Insertion went wrong. Zero rows affected".to_string()))
38                  }
39              )
40              .unwrap_or_else(|error| Err(error))
41      }
42  
43      // Функція для видалення вівці за її ідентифікатором
44      async fn delete(&self, item_id: u64) -> Result<(), Self::Error> {
45          query(
46              r#"
47              DELETE FROM Sheep
48              WHERE id = ?
49              "#
50          )
51              .bind(item_id)
52              .execute(&*self.pool).await
53              .map_err(|error| ServiceError::DatabaseError(error))
54              .map(|result|
55                  if result.rows_affected() == 0 {
56                      Err(ServiceError::CustomError("Zero rows affected".to_string()))
57                  }
58                  else{
59                      Ok(())
60                  }
61              )
62              .unwrap_or_else(|error| Err(error))
63      }
64  
65      // Функція для оновлення інформації про вівцю
66      async fn update(&self, item: Self::Model) -> Result<Self::Model, Self::Error> {
67          query(
68              r#"
69              UPDATE Sheep
70              SET birth_date = ?, breed_id = ?, weight = ?, sex = ?, temperature_scanner_id = ?, shepherd_id = ?
71              WHERE id = ?
72              "#
73          )
74              .bind(item.birth_date())
75              .bind(item.breed_id())
76              .bind(item.weight())
77              .bind(item.sex())
78              .bind(item.temperature_scanner_id())
79              .bind(item.shepherd_id())
80              .bind(item.id().ok_or(ServiceError::CustomError("ID is required".to_string()))?)
81              .execute(&*self.pool).await
82              .map_err(|error| ServiceError::DatabaseError(error))
83              .map(|result|
84                  if result.rows_affected() == 0 {
85                      Err(ServiceError::CustomError("Zero rows affected".to_string()))
86                  }
87                  else{
88                      Ok(item)
89                  }
90              )
91              .unwrap_or_else(|error|  Err(error))
92      }
93  
94      // Функція для отримання всіх овець
95      async fn get_all(&self) -> Result<Vec<Self::Model>, Self::Error> {
96          query_as::<_, Self::Model>(
97              r#"
98              SELECT * FROM Sheep
99              "#
100         )
101             .fetch_all(&*self.pool).await
102             .map_err(|error| ServiceError::DatabaseError(error))
103     }
104 
105     // Функція для отримання вівці за її ідентифікатором
106     async fn get_by_id(&self, id: u64) -> Result<Option<Self::Model>, Self::Error> {
107         query_as::<_, Self::Model>(
108             r#"
109             SELECT * FROM Sheep
110             WHERE id = ?
111             "#
112         )
113             .bind(id)
114             .fetch_optional(&*self.pool).await
115             .map_err(|error| ServiceError::DatabaseError(error))
116     }
117 }
118 
119 #[async_trait]
120 impl SheepManage<Pool<MySql>> for SheepService<Pool<MySql>>{
121     type SheepDetails = SheepDetailsVM;
122 
123     // Функція для отримання всіх ViewModel овець за ідентифікатором пастуха
124     async fn get_all_vms_by_shepherd_id(&self, id: u64) -> Result<Vec<Self::ViewModel>, Self::Error> {
125         query_as::<_, SheepVM>(
126             r#"
127             SELECT
128             s.id,
129             b.name AS breed,
130             s.sex,
131             s.birth_date,
132             (
133                 SELECT MAX(fl.timestamp)
134                 FROM FeedingLogs fl
135                 WHERE fl.sheep_id = s.id
136             ) AS last_feeding_timestamp,
137             (
138                 SELECT MAX(sl.timestamp)
139                 FROM ShearingLogs sl
140                 WHERE sl.sheep_id = s.id
141             ) AS last_shearing_timestamp
142             FROM Sheep s
143             LEFT JOIN Breeds b ON s.breed_id = b.id
144             WHERE s.shepherd_id = ?
145             "#
146         )
147             .bind(id)
148             .fetch_all(&*self.pool).await
149             .map_err(|error| ServiceError::DatabaseError(error))
150     }
151 
152     // Функція для отримання детальної інформації про вівцю за її ідентифікатором
153     async fn get_details_by_id(&self, id: u64) -> Result<Option<Self::SheepDetails>, Self::Error> {
154         query_as::<_, SheepDetailsVM>(
155             r#"
156             SELECT
157             s.id,
158             b.name AS breed,
159             b.info AS breed_info,
160             s.sex,
161             s.birth_date,
162             (
163                 SELECT MAX(fl.timestamp)
164                 FROM FeedingLogs fl
165                 WHERE fl.sheep_id = s.id
166             ) AS last_feeding_timestamp,
167             (
168                 SELECT MAX(sl.timestamp)
169                 FROM ShearingLogs sl
170                 WHERE sl.sheep_id = s.id
171             ) AS last_shearing_timestamp,
172             s.weight,
173             ts.temperature,
174             f.id AS feed_id,
175             f.name AS feed_name,
176             CAST(ROUND(
177                 CASE
178                     WHEN s.sex = true THEN s.weight * (0.05 + 0.0001 * TIMESTAMPDIFF(DAY, FROM_UNIXTIME(s.birth_date), NOW()))
179                     ELSE s.weight * (0.04 + 0.0001 * TIMESTAMPDIFF(DAY, FROM_UNIXTIME(s.birth_date), NOW()))
180                 END
181             ) AS UNSIGNED) AS required_feed_amount,
182             f.amount AS available_feed_amount
183             FROM Sheep s
184             INNER JOIN Breeds b ON s.breed_id = b.id
185             LEFT JOIN TemperatureScanners ts ON s.temperature_scanner_id = ts.id
186             INNER JOIN Feeds f ON b.feed_id = f.id
187             WHERE s.id = ?
188             "#
189         )
190             .bind(id)
191             .fetch_optional(&*self.pool).await
192             .map_err(|error| ServiceError::DatabaseError(error))
193     }
194 
195     // Функція для зміни пастуха для вівці
196     async fn change_shepherd(&self, sheep_id: u64, shepherd_id: Option<u64>) -> Result<(), Self::Error> {
197         query(
198             r#"
199             UPDATE Sheep
200             SET shepherd_id = ?
201             WHERE id = ?
202             "#
203         )
204             .bind(shepherd_id)
205             .bind(sheep_id)
206             .execute(&*self.pool).await
207             .map_err(|error| ServiceError::DatabaseError(error))
208             .map(|result|
209                 if result.rows_affected() == 0 {
210                     Err(ServiceError::CustomError("Zero rows affected".to_string()))
211                 }
212                 else{
213                     Ok(())
214                 }
215             )
216             .unwrap_or_else(|error| Err(error))
217     }
218 
219     // Функція для зміни сканера температури для вівці
220     async fn change_temperature_scanner(&self, sheep_id: u64, temperature_scanner_id: Option<u64>) -> Result<(), Self::Error> {
221         query(
222             r#"
223             UPDATE Sheep
224             SET temperature_scanner_id = ?
225             WHERE id = ?
226             "#
227         )
228             .bind(temperature_scanner_id)
229             .bind(sheep_id)
230             .execute(&*self.pool).await
231             .map_err(|error| ServiceError::DatabaseError(error))
232             .map(|result|
233                 if result.rows_affected() == 0 {
234                     Err(ServiceError::CustomError("Zero rows affected".to_string()))
235                 }
236                 else{
237                     Ok(())
238                 }
239             )
240             .unwrap_or_else(|error| Err(error))
241     }
242 }

А.3 Модуль sheep_endpoints.rs

 1  #[utoipa::path(responses(
 2      (status = 200, description = "Sheep get all"),
 3      (status = 400, description = "Validation error or bad request"),
 4      (status = 500, description = "Internal server error")
 5  ))]
 6  // Ендпойнт для отримання всіх овець
 7  #[get("/sheep")]
 8  async fn sheep_get_all(sheep_service: Data<Arc<SheepService<Pool<MySql>>>>) -> impl Responder {
 9      let result = sheep_service.get_all().await;
10      send_service_result(result)
11  }
12  
13  #[utoipa::path(params(PathId), responses(
14      (status = 200, description = "Sheep get by id"),
15      (status = 400, description = "Validation error or bad request"),
16      (status = 500, description = "Internal server error")
17  ))]
18  // Ендпойнт для отримання вівці за ідентифікатором
19  #[get("/sheep/{id}")]
20  async fn sheep_get_by_id(sheep_service: Data<Arc<SheepService<Pool<MySql>>>>, params_url: Path<PathId>) -> impl Responder {
21      let params = params_url.into_inner();
22      let result = sheep_service.get_by_id(params.id).await;
23      send_service_result(result)
24  }
25  
26  #[utoipa::path(params(PathId), responses(
27      (status = 200, description = "Sheep get details by id"),
28      (status = 400, description = "Validation error or bad request"),
29      (status = 500, description = "Internal server error")
30  ))]
31  // Ендпойнт для отримання детальної інформації про вівцю за ідентифікатором
32  #[get("/sheep/details/{id}")]
33  async fn sheep_get_details_by_id(sheep_service: Data<Arc<SheepService<Pool<MySql>>>>, params_url: Path<PathId>) -> impl Responder {
34      let params = params_url.into_inner();
35      let result = sheep_service.get_details_by_id(params.id).await;
36      send_service_result(result)
37  }
38  
39  #[utoipa::path(params(PathId), responses(
40      (status = 200, description = "Sheep get all vms by shepherd id"),
41      (status = 400, description = "Validation error or bad request"),
42      (status = 500, description = "Internal server error")
43  ))]
44  // Ендпойнт для отримання всіх ViewModel овець за ідентифікатором пастуха
45  #[get("/sheep/shepherd/{id}")]
46  async fn sheep_get_all_vms_by_shepherd_id(sheep_service: Data<Arc<SheepService<Pool<MySql>>>>, params_url: Path<PathId>) -> impl Responder {
47      let params = params_url.into_inner();
48      let result = sheep_service.get_all_vms_by_shepherd_id(params.id).await;
49      send_service_result(result)
50  }
51  
52  #[utoipa::path(responses(
53      (status = 200, description = "Sheep created"),
54      (status = 400, description = "Validation error or bad request"),
55      (status = 500, description = "Internal server error")
56  ))]
57  // Ендпойнт для створення нової вівці
58  #[post("/sheep/create")]
59  async fn sheep_create(sheep_service: Data<Arc<SheepService<Pool<MySql>>>>, sheep_json: Json<Sheep>) -> impl Responder {
60      let sheep = match validate_json_body(sheep_json) {
61          Ok(sheep) => sheep,
62          Err(error_response) => return error_response,
63      };
64      let result = sheep_service.create(sheep).await;
65      send_service_result(result)
66  }
67  
68  #[utoipa::path(responses(
69      (status = 200, description = "Sheep updated"),
70      (status = 400, description = "Validation error or bad request"),
71      (status = 500, description = "Internal server error")
72  ))]
73  // Ендпойнт для оновлення інформації про вівцю
74  #[put("/sheep/update")]
75  async fn sheep_update(sheep_service: Data<Arc<SheepService<Pool<MySql>>>>, sheep_json: Json<Sheep>) -> impl Responder {
76      let sheep = match validate_json_body(sheep_json) {
77          Ok(sheep) => sheep,
78          Err(error_response) => return error_response,
79      };
80      let result = sheep_service.update(sheep).await;
81      send_service_result(result)
82  }
83  
84  #[utoipa::path(params(PathId), responses(
85      (status = 200, description = "Sheep's shepherd changed"),
86      (status = 400, description = "Validation error or bad request"),
87      (status = 500, description = "Internal server error")
88  ))]
89  // Ендпойнт для зміни пастуха у вівці за ідентифікатором
90  #[patch("/sheep/change-shepherd/{id}")]
91  async fn sheep_change_shepherd(sheep_service: Data<Arc<SheepService<Pool<MySql>>>>, params_url: Path<PathId>, change_shepherd_json: Json<ChangeIdJson>) -> impl Responder {
92      let change_shepherd = change_shepherd_json.into_inner();
93      let params = params_url.into_inner();
94      send_service_message(sheep_service.change_shepherd(params.id, change_shepherd.change_id).await, "Changed")
95  }
96  
97  #[utoipa::path(params(PathId), responses(
98      (status = 200, description = "Sheep's temperature scanner changed"),
99      (status = 400, description = "Validation error or bad request"),
100     (status = 500, description = "Internal server error")
101 ))]
102 // Ендпойнт для зміни сканера температури у вівці за ідентифікатором
103 #[patch("/sheep/change-temperature-scanner/{id}")]
104 async fn sheep_change_temperature_scanner(sheep_service: Data<Arc<SheepService<Pool<MySql>>>>, params_url: Path<PathId>, change_temperature_scanner_json: Json<ChangeIdJson>) -> impl Responder {
105     let change_temperature_scanner = change_temperature_scanner_json.into_inner();
106     let params = params_url.into_inner();
107     send_service_message(sheep_service.change_temperature_scanner(params.id, change_temperature_scanner.change_id).await, "Changed")
108 }
109 
110 #[utoipa::path(params(PathId), responses(
111     (status = 200, description = "Sheep deleted"),
112     (status = 400, description = "Validation error or bad request"),
113     (status = 500, description = "Internal server error")
114 ))]
115 // Ендпойнт для видалення вівці за ідентифікатором
116 #[delete("/sheep/delete/{id}")]
117 async fn sheep_delete(sheep_service: Data<Arc<SheepService<Pool<MySql>>>>, params_url: Path<PathId>) -> impl Responder {
118     let params = params_url.into_inner();
119     send_service_message(sheep_service.delete(params.id).await, "Deleted")
120 }

А.4 Модуль utils.rs

 1  // Функція для валідації JSON тіла запиту
 2  pub(super) fn validate_json_body<T: Validate + Debug>(body: Json<T>) -> Result<T, HttpResponse> {
 3      match body.validate() {
 4          Ok(_) => Ok(body.into_inner()),
 5          Err(error) => {
 6              error!("Validation error of {:?}\nError: {:?}", body, &error);
 7              Err(HttpResponse::BadRequest().json(ServiceError::ValidationError(error).to_string()))
 8          }
 9      }
10  }
11  
12  // Функція для надсилання результату сервісу
13  pub(super) fn send_service_result<T: Serialize + Debug>(result: Result<T, ServiceError>) -> HttpResponse {
14      match result {
15          Ok(res) => {
16              info!("Request result: {:?}", &res);
17              HttpResponse::Ok().json(res)
18          },
19          Err(error) => {
20              error!("Request error: {:?}", &error);
21              HttpResponse::InternalServerError().json(error.to_string())
22          }
23      }
24  }
25  
26  // Функція для надсилання повідомлення сервісу
27  pub(super) fn send_service_message(result: Result<(), ServiceError>, message: &str) -> HttpResponse {
28      match result {
29          Ok(_) => {
30              info!("Request message: {:?}", message);
31              HttpResponse::Ok().json(message)
32          },
33          Err(error) => {
34              error!("Request error: {:?}", &error);
35              HttpResponse::InternalServerError().json(error.to_string())
36          }
37      }
38  }

А.5 Модуль configure.rs

 1  // Конфігурація сервісів для порід
 2  pub(crate) fn breed_configure(cfg: &mut ServiceConfig) {
 3      use breed_endpoints::*;
 4  
 5      cfg.service(breed_create)
 6          .service(breed_delete)
 7          .service(breed_update)
 8          .service(breed_get_all)
 9          .service(breed_get_all_vms)
10          .service(breed_get_by_id);
11  }
12  
13  // Конфігурація сервісів для кормів
14  pub(crate) fn feed_configure(cfg: &mut ServiceConfig) {
15      use feed_endpoints::*;
16  
17      cfg.service(feed_create)
18          .service(feed_delete)
19          .service(feed_update)
20          .service(feed_get_all)
21          .service(feed_get_all_vms)
22          .service(feed_get_by_id);
23  }
24  
25  // Конфігурація сервісів для постачання кормів
26  pub(crate) fn feed_supply_configure(cfg: &mut ServiceConfig) {
27      use feed_supply_endpoints::*;
28  
29      cfg.service(feed_supply_create)
30          .service(feed_supply_delete)
31          .service(feed_supply_get_all)
32          .service(feed_supply_get_all_vms)
33          .service(feed_supply_get_all_vms_by_feed_id)
34          .service(feed_supply_get_by_id);
35  }
36  
37  // Конфігурація сервісів для логів годування
38  pub(crate) fn feeding_log_configure(cfg: &mut ServiceConfig) {
39      use feeding_log_endpoints::*;
40  
41      cfg.service(feeding_log_create)
42          .service(feeding_log_delete)
43          .service(feeding_log_get_all)
44          .service(feeding_log_get_by_id)
45          .service(feeding_log_get_all_vms_by_feed_id)
46          .service(feeding_log_get_all_vms_by_sheep_id);
47  }
48  
49  // Конфігурація сервісів для логів стрижки
50  pub(crate) fn shearing_log_configure(cfg: &mut ServiceConfig) {
51      use shearing_log_endpoints::*;
52  
53      cfg.service(shearing_log_create)
54          .service(shearing_log_delete)
55          .service(shearing_log_get_all)
56          .service(shearing_log_get_by_id)
57          .service(shearing_log_get_all_vms_by_sheep_id);
58  }
59  
60  // Конфігурація сервісів для овець
61  pub(crate) fn sheep_configure(cfg: &mut ServiceConfig) {
62      use sheep_endpoints::*;
63  
64      cfg.service(sheep_create)
65          .service(sheep_delete)
66          .service(sheep_update)
67          .service(sheep_change_temperature_scanner)
68          .service(sheep_change_shepherd)
69          .service(sheep_get_all)
70          .service(sheep_get_all_vms_by_shepherd_id)
71          .service(sheep_get_by_id)
72          .service(sheep_get_details_by_id);
73  }
74  
75  // Конфігурація сервісів для пастухів
76  pub(crate) fn shepherd_configure(cfg: &mut ServiceConfig) {
77      use shepherd_endpoints::*;
78  
79      cfg.service(shepherd_create)
80          .service(shepherd_delete)
81          .service(shepherd_update)
82          .service(shepherd_authorize)
83          .service(shepherd_get_all)
84          .service(shepherd_get_by_id)
85          .service(shepherd_get_all_vms);
86  }
87  
88  // Конфігурація сервісів для комірників
89  pub(crate) fn storekeeper_configure(cfg: &mut ServiceConfig) {
90      use storekeeper_endpoints::*;
91  
92      cfg.service(storekeeper_create)
93          .service(storekeeper_delete)
94          .service(storekeeper_update)
95          .service(storekeeper_authorize)
96          .service(storekeeper_get_all)
97          .service(storekeeper_get_by_id);
98  }
99  
100  // Конфігурація сервісів для сканерів температури
101 pub(crate) fn temperature_scanner_configure(cfg: &mut ServiceConfig) {
102     use temperature_scanner_endpoints::*;
103 
104     cfg.service(temperature_scanner_create)
105         .service(temperature_scanner_delete)
106         .service(temperature_scanner_update)
107         .service(temperature_scanner_update_temperature)
108         .service(temperature_scanner_authenticate)
109         .service(temperature_scanner_get_all)
110         .service(temperature_scanner_get_by_id)
111         .service(temperature_scanner_get_all_unassigned_scanners_ids);
112 }
